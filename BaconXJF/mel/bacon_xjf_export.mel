/*
The MIT License (MIT)

Copyright (c) 2015 Aaron Bergstrom

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

BaconXJF 3D Web Formats Exporter
Author: Aaron Bergstrom 
E-mail: flickertail@gmail.com
*/

global int $expFormatBaconXJF = -1;
global string $expFilePathBaconXJF[];
global string $expStrBaconXJF[];
global int $expFileIdBaconXJF;
global int $depBxjf = 0;
global int $isMayaLtBxjf;
global int $isSelectBxjf;
global int $hasShdrFxBxjf;
global int $txtLinesBxjf = 1000;
global int $cgfxProfBxjf = 0;
global int $shaderConfBxjf = 0;
global string $txtLineLimitBxjf = "1000";
global int $depOffsetBxjf = 0;
global string $matsBxjf[];
global string $meshBxjf[];
global string $sgGroups[];
global string $expBxjfMName[];
global string $expBxjfID[];
global int $matSizeBxjf = 0;
global string $fPartsBxjf[];
global string $fPartNoFExt;
global string $vizorHtmlPathBaconXJF;
global string $sepBxjf = "/";
global string $bxjfType = "";
global string $bcnFormat[];
global string $expListBxjf[];
global string $bxjfUpAxis;

global proc expSetLineValueBaconxXJF()
{
global int $txtLineBxjf;
global string $txtLineLimitBxjf;
    $txtLineLimitBxjf = `textField -query -text "textFieldLineStringBaconXJF"`;
    $txtLineBxjf = (int)$txtLineLimitBxjf;
}

global proc expShaderFXProfBaconXJF()
{
global int $cgfxProfBxjf;
    $cgfxProfBxjf = `optionMenuGrp -query -select "cgfxProfileBaconXJF"` - 1;
}

global proc expShaderFXConfBaconXJF()
{
global int $shaderConfBxjf;
    $shaderConfBxjf = `optionMenuGrp -query -select "shaderConfBaconXJF"` - 1;
}

global proc deleteBaconXJFEx()
{
    if(`window -exists "baconXJFEx"`) deleteUI "baconXJFEx";
}

//global proc expStyleBaconXJF()
//{
//global int $isMayaLtBxjf;
//    $isMayaLtBxjf = `radioButtonGrp -query -select "styleBxjf"`;
//    deleteBaconXJFEx;
//    showBaconXJFEx;
//}

global proc expItemsBaconXJF()
{
global int $isSelectBxjf;
    $isSelectBxjf = `radioButtonGrp -query -select "itemsBxjf"`;
    optionVar -iv "isSelectBxjf" $isSelectBxjf; 
}

global proc string getRelativePathToAnotherFile(string $pathThatWillBeAltered, string $pathUsedForComparison)
{
global string $sepBxjf;
    string $path1[];
    string $path2[];
    
    tokenize $pathThatWillBeAltered $sepBxjf $path1;
    tokenize $pathUsedForComparison $sepBxjf $path2;
    
    int $aLen = size($path1);
    int $cLen = size($path2);
    
    int $sCount = 0;
    int $i;
    for($i=0; $i<$aLen && $i<$cLen; $i++)
    {
            if($path1[$i] == $path2[$i]) $sCount++;
    }
    
    int     $relCnt = $cLen - $sCount;
    string $relPath = "";
    
    for($i=0; $i<$relCnt; $i++) $relPath = $relPath + ".." + $sepBxjf;
    
    for($i=$sCount; $i<$aLen; $i++)
    {
        if($i == $aLen-1) $relPath = $relPath + $path1[$i];
        else              $relPath = $relPath + $path1[$i] + $sepBxjf;
    }
    
    return $relPath;

}

global proc string getRelativePathToBaconXJF(string $cPath)
{//C:\Users\aaron\Documents\aaron\BaconXJF
global string $sepBxjf;
    string   $bPath = `optionVar -q "pathToBaconXJF"`;
    string $path1[];
    string $path2[];
    
    tokenize $cPath $sepBxjf $path1;
    tokenize $bPath $sepBxjf $path2;
    
    int $cLen = size($path1);
    int $bLen = size($path2);
    
    int $sCount = 0;
    int $i;
    for($i=0; $i<$cLen && $i<$bLen; $i++)
    {
            if($path1[$i] == $path2[$i])
            {
                $sCount++;
            }
    }
    
    string $relPath = "";
    int $relCnt = 0;
    $relCnt = $bLen - $sCount;
    
    if($bLen < $cLen) $relCnt = $relCnt + $cLen - $bLen - 1;

    for($i=0; $i<$relCnt; $i++) $relPath = $relPath + ".." + $sepBxjf;
    
    for($i=$sCount; $i<$bLen; $i++) $relPath = $relPath + $path2[$i] + $sepBxjf;
    
    return $relPath;
}

global proc printBxjfStatus(string $text)
{
	print ("\n" + $text);
}
/////////////////////////////////////////////////////////////
/************************************************************
Mesh Functions
************************************************************/
global proc vector[] bcnGetMeshPointCloud(string $meshName, int $asWorld)
{
    int $cloudSize = bcnGetPointCount($meshName);
    vector $pointCloud[];
    float  $pFloats[3];
    int $i;
    for($i=0; $i<$cloudSize; $i++)
    {
        if($asWorld == 1) $pFloats = `pointPosition -world ($meshName + ".vtx[" + $i + "]")`;
        else              $pFloats = `pointPosition -local ($meshName + ".vtx[" + $i + "]")`;
        
        $pointCloud[size($pointCloud)] = << $pFloats[0], $pFloats[1], $pFloats[2] >>;
    }
    
    return $pointCloud;
}

global proc int bcnGetPointCount(string $meshName)
{
    int $pc[] = `polyEvaluate -vertex $meshName`;
    return $pc[0];
}

global proc int bcnGetFaceCount(string $meshName)
{
    int $fc[] = `polyEvaluate -face $meshName`;
    return $fc[0];
}

global proc int[] bcnGetFaceIndexSet(string $meshName)
{
    int $fis[];
    
    int $fc = bcnGetFaceCount($meshName);
    
    int $i;
    for($i=0; $i<$fc; $i++)
    {
        string  $pi[] = `polyInfo -faceToVertex ($meshName + ".f[" + $i + "]")`;
        string $pip[];
        tokenize $pi[0] $pip;
        
        int $piSize = size($pip);
        int $j;
        for($j=2; $j<$piSize; $j++)
        {
            $fis[size($fis)] = $pip[$j];
        }
        
        $fis[size($fis)] = -1;
    }
    
    return $fis;
}

global proc string[] bcnGetUVMapNames(string $meshName)
{
    string $uvMapNames[] = `polyUVSet -q -allUVSets $meshName`;
    return $uvMapNames;
}

global proc int bcnGetUVMapCount(string $meshName)
{
    string $arr[] = `polyUVSet -q -allUVSets $meshName`;
    int $len = size($arr);
    return $len;
}

global proc vector[] bcnGetUVMapCloud(string $meshName, string $mapName)
{
    select -r $meshName;
    polyUVSet -cuv -uvSet $mapName;
    select -r $meshName.map["*"];
    
    vector $uvCloud[];
    float $uvFloats[] = `polyEditUV -q -u -v`;
    int $i;
    int $s = size($uvFloats);
    for($i=0;$i<$s;$i++)
    {
        $uvCloud[size($uvCloud)] = << $uvFloats[$i], $uvFloats[$i+1], 0 >>;
        $i++;
    }
    
    return $uvCloud;
}

global proc int bcnGetUVCoordCount(string $meshName, string $mapName)
{
    int $cc[] = `polyEvaluate -uvcoord -uvSetName $mapName $meshName`;
    return $cc[0];
}

global proc int bcnGetUVIndex(string $meshName, int $face, int $vIdx, string $mapName)
{
    polyUVSet -cuv -uvSet $mapName;
    int $idx = -1;

    string $vfData[] = `polyListComponentConversion -ff -tvf ($meshName + ".f[" + $face + "]")`;
    $vfData = `ls -flatten $vfData`;

    string $useVF;
    int $i;
    int $uvDS = size($vfData);
    for($i=0; $i<$uvDS; $i++)
    {
        string $chop1[];
        string $chop2[];
        tokenize $vfData[$i] "[" $chop1;
        tokenize   $chop1[1] "]" $chop2;
        
        if(int($chop2[0]) == $vIdx) $useVF = $vfData[$i];
    }

    
    string $uvValue[] = `polyListComponentConversion -fvf -tuv $useVF`;

    if(size($uvValue) > 0 )
    {
        select -r $uvValue[0];
        float $uv[] = `polyEditUV -q -u -v`;
    
        vector $uvmap[] = bcnGetUVMapCloud($meshName, $mapName);
        int $vsize = size($uvmap);
        int $j;
        for($j=0; $j<$vsize; $j++)
        {
            vector $avec = $uvmap[$j];
            if($uv[0] == $avec.x && $uv[1] == $avec.y) $idx = $j;
        }
    }
    
    return $idx;
}

global proc vector[] bcnGetUVCoordPerVertex (string $meshName, string $uvMaps[], int $numOfFaces)
{
    int    $mCount[];
    vector $uvCoords[];
    
    int $i;
    int $s = size($uvMaps);
    for($i=0;$i<$s; $i++)
    {
        $mCount[$i] = 0;

        select -r $meshName;
        polyUVSet -cuv -uvSet $uvMaps[$i];
        
        for($j=0; $j<$numOfFaces; $j++)
        {
            string $vfData[] = `polyListComponentConversion -ff -tvf ($meshName + ".f[" + $j + "]")`;
            $vfData = `ls -flatten $vfData`;

            int $uvi;
            int $uvDS = size($vfData);
            for($uvi=0; $uvi<$uvDS; $uvi++)
            {
                string $uvValue[] = `polyListComponentConversion -fvf -tuv $vfData[$uvi]`;
                int $o;
                int $p = size($uvValue);
                for($o=0; $o<$p; $o++)
                {
                    select -r $uvValue[$o];
                    float  $uv[] = `polyEditUV -q -u -v`;
                    vector $tVec = << $uv[0], $uv[1], 0 >>;
                    $uvCoords[size($uvCoords)] = $tVec;
                     $mCount[$i] = $mCount[$i] + 1;
                }
            }
        }
    }
    
    for($i=0; $i<$s; $i++)
    {
        vector $mVec = << $mCount[$i], 0, 0 >>;
        $uvCoords[size($uvCoords)] = $mVec;
    }
    
    return $uvCoords;
}

global proc vector[] bcnGetNormalsPerVertex(string $meshName, int $vertIdxList[])
{
    vector $normals[];
    
    int $lSize = size($vertIdxList);
    int $i;
    for($i=0; $i<$lSize; $i++)
    {
        if($vertIdxList[$i] != -1)
        {
            string $vtxName = $meshName + ".vtx[" + $i + "]";
            select -r $vtxName;
            string  $pi[] = `polyInfo -vertexToFace`;
            string $pip[];
            tokenize $pi[0] $pip;
            int $pips = size($pip);
                
            int $m;
            int $faceID;
            vector $vNorm = 0;
            vector $fNorm;
                
            string $pi2[];
            string $pip2[];
            for($m=2; $m<$pips; $m++)
            {
                $faceID = $pip[$m];
                   $pi2 = `polyInfo -faceNormals ($meshName + ".f[" + $faceID + "]")`;
                tokenize $pi2[0] $pip2;
                 $fNorm  = << float($pip2[2]), float($pip2[3]), float($pip2[4]) >>;
                 $vNorm += $fNorm;
            }
            $vNorm = `unit $vNorm`;
            $normals[size($normals)] = $vNorm;
        }
    }

    return $normals;
}

global proc vector[] bcnGetNormalsPerFace(string $meshName, int $faceCount)
{
    vector $normals[];
    vector $tNorm;
    
    int $i;
    for($i=0; $i<$faceCount; $i++)
    {
        select -r ($meshName + ".f[" + $i + "]");
        string     $pi[] = `polyInfo -faceNormals`;
        string $nText[];
        
        tokenize $pi[0] $nText;
        
        $tNorm = << float($pi[2]), float($pi[3]), float($pi[4]) >>;
        $normals[size($normals)] = $tNorm;
    }

    return $normals;
}

/***********************************************************/

global proc prtLineBxjf(string $bftxLine)
{
global int $expFileIdBaconXJF;
global string $expFilePathBaconXJF[];
global int $depBxjf;
global int $isMayaLtBxjf;
global int $depOffsetBxjf;
global string $expStrBaconXJF[];

    string $tLine = "";
     
    for($i=0; $i<$depBxjf; $i++) $tLine = "\t"+$tLine;
    $tLine = $tLine + $bftxLine;
    if($isMayaLtBxjf == false)
    {
        $tLine = $tLine + "\n";
        fprint $expFileIdBaconXJF $tLine;
    }
    else $expStrBaconXJF[size($expStrBaconXJF)] = $tLine;
}

global proc writeFileHeaderBaconXJF()
{
global int $expFormatBaconXJF;
global string $expFilePathBaconXJF[];
global int $depBxjf;
global int $depOffsetBxjf;
global string $bxjfType;
global string $bcnFormat[];

    switch($bcnFormat[$expFormatBaconXJF])
    {
        case "bcnFileFormat":
            break;
        case "vzrFileFormat":
        	setUpAxis "z";
            $bxjfType = "Vizor";
            prtLineBxjf "processVizorScene({";
            break;
        case "gltfFileFormat":
            $bxjfType = "Gltf";
            prtLineBxjf "{";
            break;
        case "tjsFileFormat":
            $bxjfType = "Threejs";
            prtLineBxjf "{";
            break;
        case "x3dvFileFormat":
            $bxjfType = "X3DC";
            prtLineBxjf "#X3D V3.0 utf8";
            prtLineBxjf "PROFILE Interchange";
            break;
        case "x3djFileFormat":
            $bxjfType = "X3DJ";
            prtLineBxjf "[";
            $depBxjf++;
            prtLineBxjf "{";
            $depBxjf++;
            prtLineBxjf "\"X3D\":";
            prtLineBxjf "{";
            $depBxjf++;
            prtLineBxjf "\"@profile\":\"Interchange\",";
            prtLineBxjf "\"@version\":3.3,";
            prtLineBxjf "\"@xsd:noNamespaceSchemaLocation\":\"http://www.web3d.org/specifications/x3d-3.3.xsd\"";
            break;
        case "x3dxFileFormat":
            $bxjfType = "X3DX";
            prtLineBxjf "<?xml version=\"1.0\" encoding=\"utf-8\"?>";
            prtLineBxjf "<!DOCTYPE X3D PUBLIC \"ISO//Web3D//DTD X3D 3.0//EN\"  \"http://www.web3d.org/specifications/x3d-3.0.dtd\">";
            string $x3dArray[];
            $x3dArray[size($x3dArray)] = getXmlFltField("version", 3.0);
            $x3dArray[size($x3dArray)] = getXmlStrField("profile", "Interchange");
            prtLineBxjf(getXmlStartTag("X3D", $x3dArray, false));
            break;
        case "x3dhFileFormat":
            $bxjfType = "X3DH";
            prtLineBxjf "<?xml version=\"1.0\" encoding=\"utf-8\"?>";
            prtLineBxjf "<!DOCTYPE X3D PUBLIC \"ISO//Web3D//DTD X3D 3.0//EN\"  \"http://www.web3d.org/specifications/x3d-3.0.dtd\">";
            string $x3dArray[];
            $x3dArray[size($x3dArray)] = getXmlFltField("version", 3.0);
            $x3dArray[size($x3dArray)] = getXmlStrField("profile", "Interchange");
            prtLineBxjf(getXmlStartTag("X3D", $x3dArray, false));
            break;
        default:
            prtLineBxjf "Failure Start";
            break;
    }
}

global proc writeMetadataBaconXJF()
{
global string $expFilePathBaconXJF[];
global string $matsBxjf[];
global string $meshBxjf[];
global int $expFormatBaconXJF;
global int $depBxjf;
global int $matSizeBxjf;
global string $fPartsBxjf[];
global string $fPartNoFExt;
global string $bcnFormat[];


    $matsBxjf = `ls -mat`;
    string $pcBxjf[] = `ls -type "particleCloud"`;
    string $cgfxShader[] = `ls -type "cgfxShader"`;
    string $occShader[] = `ls -type "ilrOccSampler"`;
    $matSizeBxjf = size($matsBxjf) - size($pcBxjf) - size($cgfxShader) - size($occShader);

//    string $phongs[] = `ls -type phong`;
//    string $shdrfx[] = `ls -type ShaderfxShader`;
    
//    for($idx = 0; $idx<size($phongs); $idx++) $matsBxjf[size($matsBxjf)] = $phongs[$idx];
//    for($idx = 0; $idx<size($shdrfx); $idx++) $matsBxjf[size($matsBxjf)] = $shdrfx[$idx];
    
    $meshBxjf = `ls -type mesh`;
    
    int $vertNum = 0;
    int $faceNum = 0;
    int $normNum = 0;
    int $colorNum = 0;
    int $uvNum = 0;
    
    int $ctNums[];
    
    for($meshIdx in $meshBxjf)
    {
        $ctNums  = `polyEvaluate -v -f -uv $meshIdx`;
        $vertNum = $vertNum + $ctNums[0];
        $faceNum = $faceNum + $ctNums[1];
        $uvNum   = $uvNum   + $ctNums[2];
//        string $values = "Verts: " + $vertNum + ", Faces: " + $faceNum + ", UVs: " + $uvNum + "\n";
//        print $values;
    }
        
    string $tMetaLine = "";

    switch($bcnFormat[$expFormatBaconXJF])
    {
        case "vzrFileFormat":
            int $len = size($fPartsBxjf);
            $depBxjf++;
            string $metaData = "\"id\": \"" +  $fPartNoFExt  + "_json\",";
            prtLineBxjf $metaData;
            break;
        case "gltfFileFormat":
//            prtLineBxjf "{";
            break;
        case "tjsFileFormat":
            $depBxjf++;
            prtLineBxjf "\"metadata\":";
            prtLineBxjf "{";
            //
            $depBxjf++;
            
            $tMetaLine = "\"sourceFile\": \"" + `file -q -sn` + "\"";
            prtLineBxjf $tMetaLine;
            
            prtLineBxjf "\"generatedBy\": \"MayaLT 2015 - Using: BaconXJF\",";
            
            $tMetaLine = "\"vertices\": " + $vertNum + ",";
            prtLineBxjf $tMetaLine;
            
            $tMetaLine = "\"faces\": " + $faceNum + ",";
            prtLineBxjf $tMetaLine;
            
            $tMetaLine = "\"normals\": " + $normNum + ",";
            prtLineBxjf $tMetaLine;
            
            $tMetaLine = "\"colors\": " + $colorNum + ",";
            prtLineBxjf $tMetaLine;
            
            $tMetaLine = "\"uvs\": " + $uvNum + ",";
            prtLineBxjf $tMetaLine;
            
            $tMetaLine = "\"materials\": " + $matSizeBxjf;
            prtLineBxjf $tMetaLine;

            $depBxjf--;
            //
            prtLineBxjf "},";
            $depBxjf--;
            break;
        case "x3dvFileFormat":
            string $metaInfo =  "META \"filename\" \"" + $expFilePathBaconXJF[2] + "\"";
            prtLineBxjf $metaInfo;
            break;
        case "x3djFileFormat":
            prtLineBxjf "\"head\":";
            prtLineBxjf "[";
            $depBxjf++;
            prtLineBxjf "{";
            $depBxjf++;
            prtLineBxjf "\"meta\":";
            prtLineBxjf "{";
            $depBxjf++;
            string $metaInfo = "\"@content\":\"" + $expFilePathBaconXJF[2] + "\",";
            prtLineBxjf $metaInfo;
            prtLineBxjf "\"@name\":\"filename\"";
            $depBxjf--;
            prtLineBxjf "}";
            $depBxjf--;
            prtLineBxjf "}";
            $depBxjf--;
            prtLineBxjf "],";
            break;
        case "x3dxFileFormat":
            $depBxjf++;
            string $empty[];
            string $x3dString = getXmlStartTagNF("head");
            prtLineBxjf($x3dString);
            
            $depBxjf++;
            string $x3dArray[];
            $x3dArray[size($x3dArray)] = getXmlStrField("name", "filename");
            $x3dArray[size($x3dArray)] = getXmlStrField("content", $expFilePathBaconXJF[2]);
            prtLineBxjf(getXmlStartTag("meta", $x3dArray, true));
            
            $depBxjf--;
            prtLineBxjf(getXmlEndTag("head",""));
            break;
        case "x3dhFileFormat":
            $depBxjf++;
            string $empty[];
            prtLineBxjf(getXmlStartTagNF("head"));
            
            $depBxjf++;
            string $x3dArray[];
            $x3dArray[size($x3dArray)] = getXmlStrField("name", "filename");
            $x3dArray[size($x3dArray)] = getXmlStrField("content", $expFilePathBaconXJF[2]);
            prtLineBxjf(getXmlStartTag("meta", $x3dArray, true));
            
            $depBxjf--;
            prtLineBxjf(getXmlEndTag("head",""));
            break;
        default:
            prtLineBxjf "Failure Start";
            break;
    }
    
}

global proc writeMaterialsBaconXJF()
{
global string $matsBxjf[];
global int $matSizeBxjf;
global int $expFormatBaconXJF;
global int $depBxjf;
global string $expBxjfMName[];
global string $expBxjfID[];
global string $bcnFormat[];

    int $expIdx  = -1;
    int $ebSize  =  0;
    int $iExpIdx =  0;
    string $tempLine = "";
    int $cCount = 0;
    switch($bcnFormat[$expFormatBaconXJF])
    {
        case "vzrFileFormat":
            writeVzrMaterialsBxjf();
            break;
        case "tjsFileFormat":
            $depBxjf++;
            $tempLine = "\"materials\":";
            prtLineBxjf $tempLine;
            prtLineBxjf "[";
            $depBxjf++;
            
            for($mIdx=0; $mIdx<size($matsBxjf); $mIdx++)
            {
                string $tType = `nodeType $matsBxjf[$mIdx]`;
                switch($tType)
                {
                    case "phong":
                        prtLineBxjf "{";
                        $depBxjf++;
                        $cCount++;

                        string $phUUID = getUUIDBaconXJF($matsBxjf[$mIdx]);
                        
                        $tempLine = "\"uuid\": \"" + $phUUID + "\"";
                        prtLineBxjf $tempLine;
                        
                        $tempLine = "\"type\": \"MeshPhongMaterial\"";
                        prtLineBxjf $tempLine;
                        
                        $depBxjf--;
                        $tempLine = "}";
                        if($cCount != $matSizeBxjf) $tempLine = $tempLine + ",";
                        prtLineBxjf $tempLine;
                        break;
                    case "lambert":
                        prtLineBxjf "{";
                        $depBxjf++;
                        $cCount++;

                        string $laUUID = getUUIDBaconXJF($matsBxjf[$mIdx]);
                        
                        $tempLine = "\"uuid\": \"" + $laUUID + "\"";
                        prtLineBxjf $tempLine;
                        
                        $tempLine = "\"type\": \"MeshLambertMaterial\"";
                        prtLineBxjf $tempLine;
                        
                        $depBxjf--;
                        $tempLine = "}";
                        if($cCount != $matSizeBxjf) $tempLine = $tempLine + ",";
                        prtLineBxjf $tempLine;
                        break;
                    case "ShaderfxShader":
                        prtLineBxjf "{";
                        $depBxjf++;
                        $cCount++;

                        string $sfxUUID = getUUIDBaconXJF($matsBxjf[$mIdx]);
                        
                        $tempLine = "\"uuid\": \"" + $sfxUUID + "\"";
                        prtLineBxjf $tempLine;
                        
                        $tempLine = "\"type\": \"MeshBasicMaterial\"";
                        prtLineBxjf $tempLine;
                        
                        $depBxjf--;
                        $tempLine = "}";
                        if($cCount != $matSizeBxjf) $tempLine = $tempLine + ",";
                        prtLineBxjf $tempLine;
                        break;
                    default:
                        break;
                }
            }
            $depBxjf--;
            prtLineBxjf "],";
            $depBxjf--;
            break;
        case "x3dxFileFormat":
            writeX3dxMaterialsBxjf();
            break;
        case "x3dhFileFormat":
            writeX3dxMaterialsBxjf();
            break;
        default:
            break;
    }
}

global proc writeTexturesBaconXJF()
{
}

global proc writeSceneGraphBaconXJF()
{
global string $sgGroups[];
global int $expFormatBaconXJF;
global int $depBxjf;
global string $bcnFormat[];

    int $size = size($sgGroups);
    switch($bcnFormat[$expFormatBaconXJF])
    {
        
        case "vzrFileFormat":
            writeVzrShapesBxjf();
            break;
        case "gltfFileFormat":
            for($i=0;$i<$size;$i++) traverseSGgltfBaconXJF($sgGroups[$i], "", 0);
            break;
        case "tjsFileFormat":
            $depBxjf++;
            string $tempBxjf = "";
            $tempBxjf = "\"object\":";
            prtLineBxjf $tempBxjf;
            prtLineBxjf "{";
                
            $depBxjf++;
                
            $tempBxjf = "\"uuid\": \"" + genUUIDBaconXJF() + "\",";
            prtLineBxjf $tempBxjf;
                
            $tempBxjf = "\"type\": \"Scene\",";
            prtLineBxjf $tempBxjf;
                
            $tempBxjf = "\"matrix\": [1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],";
            prtLineBxjf $tempBxjf;
                
            $tempBxjf = "\"children\": ";
            prtLineBxjf $tempBxjf;
            prtLineBxjf "[";
                
            for($i=0;$i<$size;$i++)
            {
                int $hmc = 0;
                int $myCheck = $size-1;
                if($i < $myCheck) $hmc = 1;
                traverseSGthreejsBaconXJF($sgGroups[$i], $hmc);
            }
            prtLineBxjf "]";
            $depBxjf--;
            prtLineBxjf "}";
            $depBxjf--;
            break;
        case "x3dvFileFormat":
            for($i=0;$i<$size;$i++)
            {
                print "It was called.";
                   traverseSGx3dBaconXJF($sgGroups[$i], "", 0);
                   $depBxjf--;
            }
            break;        
        case "x3djFileFormat":
            prtLineBxjf "\"Scene\":";
            prtLineBxjf "[";
            for($i=0;$i<$size;$i++)
            {
                traverseSGx3dBaconXJF($sgGroups[$i], "", 0);
                $depBxjf--;
            }
            prtLineBxjf "]";
            break;        
        case "x3dxFileFormat":
            prtLineBxjf(getXmlStartTagNF("Scene"));
            for($i=0;$i<$size;$i++)
            {
                traverseSGx3dBaconXJF($sgGroups[$i], "", 0);
                $depBxjf--;
            }
            prtLineBxjf(getXmlEndTag("Scene",""));
            break;
        case "x3dhFileFormat":
            prtLineBxjf(getXmlStartTagNF("Scene"));
            for($i=0;$i<$size;$i++)
            {
                traverseSGx3dBaconXJF($sgGroups[$i], "", 0);
                $depBxjf--;
            }
            prtLineBxjf(getXmlEndTag("Scene",""));
            break;
        default:
            break;
    }        
}

global proc writeFileFooterBaconXJF()
{
global int $expFormatBaconXJF;
global int $expFileIdBaconXJF;
global int $depBxjf;
global string $bcnFormat[];

    switch($bcnFormat[$expFormatBaconXJF])
    {
        case "vzrFileFormat":
            $depBxjf--;
            prtLineBxjf "});";
            break;
        case "gltfFileFormat":
            prtLineBxjf "}";
            break;
        case "tjsFileFormat":
            prtLineBxjf "}";
            break;
        case "x3dvFileFormat":
            break;
        case "x3djFileFormat":
            $depBxjf--;
            prtLineBxjf "}";
            $depBxjf--;
            prtLineBxjf "}";
            $depBxjf--;
            prtLineBxjf "]";
            break;
        case "x3dxFileFormat":
            $depBxjf--;
            prtLineBxjf(getXmlEndTag("X3D",""));
            break;        
        case "x3dhFileFormat":
            $depBxjf--;
            prtLineBxjf(getXmlEndTag("X3D",""));
            break;        
        default:
            prtLineBxjf "Failure End";
            break;
    }    
}

global proc expSelBaconXJF()
{
global int $expFormatBaconXJF;
global string $expFilePathBaconXJF[];
global int $expFileIdBaconXJF;
global int $depBxjf;
global int $isMayaLtBxjf;
global string $expStrBaconXJF[];
global int $isSelectBxjf;
global string $sgGroups[];
global string $expBxjfMName[];
global string $expBxjfID[];
global string $fPartsBxjf[];
global string $fPartNoFExt;
global string $vizorHtmlPathBaconXJF;
global string $sepBxjf;
global string $bcnFormat[];
global string $expListBxjf[];
global string $bxjfUpAxis;

    int $selItems[] = `textScrollList -query -sii "bftxTSL"`;
    
    $expFormatBaconXJF = $selItems[0]-1;
    
    switch($bcnFormat[$expFormatBaconXJF])
    {
        case "bcnFileFormat":
            $expFilePathBaconXJF = `fileDialog2 -fm 0 -cap "Export Bacon Wrap" -ff "Bacon Wrap (*.bcnwrp)" -okc "Save" -cc "Cancel"`;
            break;
        case "vzrFileFormat":
            $expFilePathBaconXJF = `fileDialog2 -fm 0 -cap "Export Vizor VR" -ff "Vizor VR (*.vzrwrp)" -okc "Save" -cc "Cancel"`;
            break;
        case "gltfFileFormat":
            $expFilePathBaconXJF = `fileDialog2 -fm 0 -cap "Export glFT" -ff "glFT (*.json)" -okc "Save" -cc "Cancel"`;
            break;
        case "tjsFileFormat":
            $expFilePathBaconXJF = `fileDialog2 -fm 0 -cap "Export ThreeJS" -ff "ThreeJS (*.json)" -okc "Save" -cc "Cancel"`;
            break;
        case "x3dvFileFormat":
            $expFilePathBaconXJF = `fileDialog2 -fm 0 -cap "Export X3D Classic" -ff "X3D Classic (*.x3dv)" -okc "Save" -cc "Cancel"`;
            break;
        case "x3djFileFormat":
            $expFilePathBaconXJF = `fileDialog2 -fm 0 -cap "Export X3D xml" -ff "X3D JSON (*.json)" -okc "Save" -cc "Cancel"`;
            break;
        case "x3dxFileFormat":
            $expFilePathBaconXJF = `fileDialog2 -fm 0 -cap "Export X3D xml" -ff "X3D xml (*.x3d)" -okc "Save" -cc "Cancel"`;
            break;
        case "x3dhFileFormat":
            $expFilePathBaconXJF = `fileDialog2 -fm 0 -cap "Export XHTML" -ff "XHMTL (*.html)" -okc "Save" -cc "Cancel"`;
            break;
        case "bjsFileFormat":
            $expFilePathBaconXJF = `fileDialog2 -fm 0 -cap "Export BabylonJS" -ff "BabylonJS (*.json)" -okc "Save" -cc "Cancel"`;
            break;
        default:
            $expFilePathBaconXJF = `fileDialog2 -fm 0 -cap "Export Failure" -ff "Failure (*.fail)" -okc "Save" -cc "Cancel"`;
            break;
    }
    
    if($expFilePathBaconXJF[0] != "")
    {
        tokenize $expFilePathBaconXJF[0] $sepBxjf $fPartsBxjf;
        int $len = size($fPartsBxjf);

        $expFilePathBaconXJF[1] = $fPartsBxjf[0];
        string $apart = ("Index 0: " + $fPartsBxjf[0] + "\n");
        print $apart;
        for($i=1; $i<($len-1); $i++) $expFilePathBaconXJF[1] = $expFilePathBaconXJF[1] + $sepBxjf + $fPartsBxjf[$i];
        
        string $fNamePrts[];
        tokenize $fPartsBxjf[$len-1] "." $fNamePrts;
        $fPartNoFExt = $fNamePrts[0];
        if($expFormatBaconXJF == 1) $vizorHtmlPathBaconXJF = $expFilePathBaconXJF[1] + $sepBxjf + $fPartNoFExt + ".html";

        $expFilePathBaconXJF[2] = $fPartsBxjf[size($fPartsBxjf)-1];
        print $expFilePathBaconXJF;
        
        if($isMayaLtBxjf == false)
        {
            $expFileIdBaconXJF = `fopen $expFilePathBaconXJF[0] "w"`;
        }
        else clear $expStrBaconXJF;

        clear $sgGroups;
        clear $expBxjfMName;
        clear $expBxjfID;

		string $topTrans[];
		        
        if(`radioButtonGrp -query -select "itemsBxjf"` == 2) $topTrans = `ls -selection`;
        else $topTrans = `ls -as`;
        
        for($t in $topTrans)
        {
        	if($t != "persp" && $t != "top" && $t != "side" && $t != "front")
            {
            	if(`getAttr($t + ".visibility")`) $sgGroups[size($sgGroups)] = $t;
            }
        }
        
        string $ff = $bcnFormat[$expFormatBaconXJF];
        if($ff == "x3dvFileFormat" || $ff == "x3dxFileFormat" || $ff == "x3djFileFormat" || $ff == "x3dhFileFormat") processX3DBaconXJF($ff);
        else
        {
        	writeFileHeaderBaconXJF();
        	writeMetadataBaconXJF();
        	writeMaterialsBaconXJF();
        	writeTexturesBaconXJF();
        	writeSceneGraphBaconXJF();
        	writeFileFooterBaconXJF();

        	if($expFormatBaconXJF == 1) prtVizorHTMLBxjf();        
        }
        
        if($isMayaLtBxjf == false) fclose $expFileIdBaconXJF;
        else fwriteAllLines $expFilePathBaconXJF[0] $expStrBaconXJF;

    	string $outputBxjf = "File Exported: " + $expFilePathBaconXJF[0] + "\n";
    	printBxjfStatus($outputBxjf);
    	if($expFormatBaconXJF == 1)
    	{
        	string $prtOutVizorHtmlPath = ("HTML Saved to: " + $vizorHtmlPathBaconXJF);
        	printBxjfStatus($prtOutVizorHtmlPath);
        	launch -web $vizorHtmlPathBaconXJF;
    	}
    }
    else
    {
    	print "ERROR: No output file designated!\n";
    }
    deleteBaconXJFEx;
    
    //Removing temporary attributes that were used to test
    //whether or not a node had already been exported.
    //Then we erase the list of nodes.
    int $els = size($expListBxjf);
    int $iels;
    for($iels = 0; $iels<$els; $iels++)
    {
		//todo account for X3D Export tracking attribute.
        deleteAttr ($expListBxjf[$iels] + ".bcnco");
    }
    
    string $newList[];
    $expListBxjf = $newList;
    
    $depBxjf = 0;
    
    setUpAxis $bxjfUpAxis;
}

global proc showBaconXJFEx()
{
global int $isSelectBxjf;
global int $isMayaLtBxjf;
global int $hasShdrFxBxjf;
global int $cgfxProfBxjf;
global int $shaderConfBxjf;
global string $txtLineLimitBxjf;
global string $sepBxjf;
global string $bcnFormat[];

    $bcnFormat = {"bcnFileFormat","vzrFileFormat","x3dvFileFormat","x3djFileFormat","x3dxFileFormat","x3dhFileFormat","tjsFileFormat","gltfFileFormat","bjsFileFormat"};
    
	string $testLines[];
    string $bPath = `optionVar -q "pathToBaconXJF"`;
    $isSelectBxjf = `optionVar -q "isSelectBxjf"`;
	$isMayaLtBxjf = `about -lt`;
    
	int $ovExist_hasShdrFxBxjf = `optionVar -ex "hasShdrFxBxjf"`;
    if($ovExist_hasShdrFxBxjf == 1 ) $hasShdrFxBxjf = `optionVar -q "hasShdrFxBxjf"`;
    else
    {
    	string $dNode[] = `ls -sl`;
    	int $tc = catch( `shadingNode -asShader ShaderfxShader`  );
    	string $aNode[] = `ls -sl`;
    	
    	if(size($aNode) > 0)
    	{
    		if(size($dNode) == 0) $tc = true;
    		else if($aNode[0] == $dNode[0]) $tc = false;
    		else $tc = true;
    		
    		if($tc == true) delete;
    	}
    
    	$hasShdrFxBxjf = $tc;
		optionVar -iv "hasShdrFxBxjf" $hasShdrFxBxjf;
	}
	
    if(!`window -exists "baconXJFEx"`)
    {
        window -title "BaconXJF - 3D Web Format Exporter" -widthHeight 350 360 "baconXJFEx";
        scrollLayout -w 350 -h 360;
            columnLayout "mainColBXJFEX";
                radioButtonGrp -numberOfRadioButtons 2 -label "Items to Export:" -labelArray2 "All" "Selected" -select $isSelectBxjf -columnAlign3 "left" "left" "left" -columnWidth3 80 35 60 -cc "expItemsBaconXJF" "itemsBxjf";
//                radioButtonGrp -numberOfRadioButtons 2 -label "Export Using MayaLT Style:" -labelArray2 "No" "Yes" -select $isMayaLtBxjf -columnAlign3 "left" "left" "left" -columnWidth3 150 35 35 -cc "expStyleBaconXJF" "styleBxjf";
                rowLayout -nc 3 -cw3 30 120 80;
                    text -label " ";
                    text -label "Lines Per Export File: ";
                    textField -text $txtLineLimitBxjf -w 80 -cc "expSetLineValueBaconxXJF" "textFieldLineStringBaconXJF";
                    setParent "mainColBXJFEX";
                text -label "Format:";
                textScrollList -numberOfRows 8
                               -allowMultiSelection false
                               -append "Bacon Wrap"    //BaconXJF Format
                               -append "Vizor VR { JSON }"      //Vizor VR
                               -append "X3D {classic}" //X3D {classic}
                               -append "X3D { JSON  }" //X3D { JSON  }
                               -append "X3D <  xml  >" //X3D <  xml  >
                               -append "XHTML <3D html>" //XHTML
                               -append "ThreeJS { JSON }" //ThreeJS"
                               -append "glTF { JSON }" //glTF
                               -append "BabylonJS { JSON }"
                               -selectItem "Vizor VR { JSON }" "bftxTSL";

                if($hasShdrFxBxjf)
                {
                    int $profValBxjf = $cgfxProfBxjf + 1;
                    int $confValBxjf = $shaderConfBxjf + 1;

                    separator -h 5;

                    text -label "ShaderFX Settings:";
                    
                    rowLayout -nc 2 -cw2 30 160;
                        text -label " ";
                        optionMenuGrp -l "CGFX Profile: " -cw2 80 80 -cl2 "left" "left" -cc "expShaderFXProfBaconXJF" "cgfxProfileBaconXJF";
                            menuItem -label "glsl";
                            menuItem -label "gp4";
                            
                        optionMenuGrp -e -select $profValBxjf "cgfxProfileBaconXJF";
                        setParent "mainColBXJFEX";
                    rowLayout -nc 2 -cw2 30 160;
                        text -label " ";
                        optionMenuGrp -l "Shader Config: " -cw2 80 80 -cl2 "left" "left" -cc "expShaderFXConfBaconXJF" "shaderConfBaconXJF";
                            menuItem -label "HLSL_3";
                            menuItem -label "HLSL_5";
                            menuItem -label "GLSL_1_2";
                            menuItem -label "GLSL_4";
                            menuItem -label "CGFX_3";
                            menuItem -label "OSL";
                            
                        optionMenuGrp -e -select $confValBxjf "shaderConfBaconXJF";
                }
                setParent "mainColBXJFEX";
                separator -h 25;
                rowLayout -nc 3 -cw3 120 120 120;
                    text -label " ";//button -label "Debug - Delete Window" -command "deleteBaconXJFEx";
                    text -label " ";
                    button -label "Export File" -command "expSelBaconXJF";
                    
                    setParent "mainColBXJFEX";
                separator -h 10;
                cmdScrollFieldReporter -width 340 -height 60;
    }
    showWindow "baconXJFEx";
    print "\n";
    print "\n";
    print "\n";
}

global proc bacon_xjf_export()
{
global string $bxjfUpAxis;

	$bxjfUpAxis = `upAxis -q -axis`;
	bacon_xjf_json;
	bacon_xjf_vizor;
	bacon_xjf_threejs;
	bacon_xjf_gltf;
	bacon_xjf_babylonjs;
	bacon_xjf_xml;
	bacon_xjf_x3d;
	showBaconXJFEx;
}

//showBaconXJFEx;
