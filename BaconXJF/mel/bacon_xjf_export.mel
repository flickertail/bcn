/*
The MIT License (MIT)

Copyright (c) 2015 Aaron Bergstrom

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

BaconXJF JSON Exporter
Author: Aaron Bergstrom 
E-mail: flickertail@gmail.com
*/

global int $expFormatBaconXJF = -1;
global string $expFilePathBaconXJF[];
global string $expStrBaconXJF[];
global int $expFileIdBaconXJF;
global int $depBxjf = 0;
global int $isMayaLtBxjf;
global int $isSelectBxjf;
global int $hasShdrFxBxjf;
global int $txtLinesBxjf = 1000;
global int $cgfxProfBxjf = 0;
global int $shaderConfBxjf = 0;
global string $txtLineLimitBxjf = "1000";
global int $depOffsetBxjf = 0;
global string $matsBxjf[];
global string $meshBxjf[];
global string $sgGroups[];
global string $expBxjfMName[];
global string $expBxjfID[];
global int $matSizeBxjf = 0;
global string $fPartsBxjf[];
global string $fPartNoFExt;
global string $vizorHtmlPathBaconXJF;
global string $sepBxjf = "/";
global string $bxjfType = "";
global string $bcnFormat[];
global string $expListBxjf[];

global proc expSetLineValueBaconxXJF()
{
global int $txtLineBxjf;
global string $txtLineLimitBxjf;
    $txtLineLimitBxjf = `textField -query -text "textFieldLineStringBaconXJF"`;
    $txtLineBxjf = (int)$txtLineLimitBxjf;
}

global proc expShaderFXProfBaconXJF()
{
global int $cgfxProfBxjf;
    $cgfxProfBxjf = `optionMenuGrp -query -select "cgfxProfileBaconXJF"` - 1;
}

global proc expShaderFXConfBaconXJF()
{
global int $shaderConfBxjf;
    $shaderConfBxjf = `optionMenuGrp -query -select "shaderConfBaconXJF"` - 1;
}

global proc deleteBaconXJFEx()
{
    if(`window -exists "baconXJFEx"`) deleteUI "baconXJFEx";
}

global proc expStyleBaconXJF()
{
global int $isMayaLtBxjf;
    $isMayaLtBxjf = `radioButtonGrp -query -select "styleBxjf"`;
    deleteBaconXJFEx;
    showBaconXJFEx;
}

global proc expItemsBaconXJF()
{
global int $isSelectBxjf;
    $isSelectBxjf = `radioButtonGrp -query -select "itemsBxjf"`;
    optionVar -iv "isSelectBxjf" $isSelectBxjf; 
}

global proc string getRelativePathToAnotherFile(string $pathThatWillBeAltered, string $pathUsedForComparison)
{
global string $sepBxjf;
    string $path1[];
    string $path2[];
    
    tokenize $pathThatWillBeAltered $sepBxjf $path1;
    tokenize $pathUsedForComparison $sepBxjf $path2;
    
    int $aLen = size($path1);
    int $cLen = size($path2);
    
    int $sCount = 0;
    int $i;
    for($i=0; $i<$aLen && $i<$cLen; $i++)
    {
            if($path1[$i] == $path2[$i]) $sCount++;
    }
    
    int     $relCnt = $cLen - $sCount;
    string $relPath = "";
    
    for($i=0; $i<$relCnt; $i++) $relPath = $relPath + ".." + $sepBxjf;
    
    for($i=$sCount; $i<$aLen; $i++)
    {
        if($i == $aLen-1) $relPath = $relPath + $path1[$i];
        else              $relPath = $relPath + $path1[$i] + $sepBxjf;
    }
    
    return $relPath;

}

global proc string getRelativePathToBaconXJF(string $cPath)
{//C:\Users\aaron\Documents\aaron\BaconXJF
global string $sepBxjf;
    string   $bPath = `optionVar -q "pathToBaconXJF"`;
    string $path1[];
    string $path2[];
    
    tokenize $cPath $sepBxjf $path1;
    tokenize $bPath $sepBxjf $path2;
    
    int $cLen = size($path1);
    int $bLen = size($path2);
    
    int $sCount = 0;
    int $i;
    for($i=0; $i<$cLen && $i<$bLen; $i++)
    {
            if($path1[$i] == $path2[$i])
            {
                $sCount++;
            }
    }
    
    string $relPath = "";
    int $relCnt = 0;
    $relCnt = $bLen - $sCount;
    
    if($bLen < $cLen) $relCnt = $relCnt + $cLen - $bLen - 1;

    for($i=0; $i<$relCnt; $i++) $relPath = $relPath + ".." + $sepBxjf;
    
    for($i=$sCount; $i<$bLen; $i++) $relPath = $relPath + $path2[$i] + $sepBxjf;
    
    return $relPath;
}
global proc printBxjfStatus(string $text)
{
	print ("\n" + $text);
}
/////////////////////////////////////////////////////////////
/************************************************************
Mesh Functions
************************************************************/
global proc vector[] bcnGetMeshPointCloud(string $meshName, int $asWorld)
{
    int $cloudSize = bcnGetPointCount($meshName);
    vector $pointCloud[];
    float  $pFloats[3];
    int $i;
    for($i=0; $i<$cloudSize; $i++)
    {
        if($asWorld == 1) $pFloats = `pointPosition -world ($meshName + ".vtx[" + $i + "]")`;
        else              $pFloats = `pointPosition -local ($meshName + ".vtx[" + $i + "]")`;
        
        $pointCloud[size($pointCloud)] = << $pFloats[0], $pFloats[1], $pFloats[2] >>;
    }
    
    return $pointCloud;
}

global proc int bcnGetPointCount(string $meshName)
{
    int $pc[] = `polyEvaluate -vertex $meshName`;
    return $pc[0];
}

global proc int bcnGetFaceCount(string $meshName)
{
    int $fc[] = `polyEvaluate -face $meshName`;
    return $fc[0];
}

global proc int[] bcnGetFaceIndexSet(string $meshName)
{
    int $fis[];
    
    int $fc = bcnGetFaceCount($meshName);
    
    int $i;
    for($i=0; $i<$fc; $i++)
    {
        string  $pi[] = `polyInfo -faceToVertex ($meshName + ".f[" + $i + "]")`;
        string $pip[];
        tokenize $pi[0] $pip;
        
        int $piSize = size($pip);
        int $j;
        for($j=2; $j<$piSize; $j++)
        {
            $fis[size($fis)] = $pip[$j];
        }
        
        $fis[size($fis)] = -1;
    }
    
    return $fis;
}

global proc string[] bcnGetUVMapNames(string $meshName)
{
    string $uvMapNames[] = `polyUVSet -q -allUVSets $meshName`;
    return $uvMapNames;
}

global proc int bcnGetUVMapCount(string $meshName)
{
    string $arr[] = `polyUVSet -q -allUVSets $meshName`;
    int $len = size($arr);
    return $len;
}

global proc vector[] bcnGetUVMapCloud(string $meshName, string $mapName)
{
    select -r $meshName;
    polyUVSet -cuv -uvSet $mapName;
    select -r $meshName.map["*"];
    
    vector $uvCloud[];
    float $uvFloats[] = `polyEditUV -q -u -v`;
    int $i;
    int $s = size($uvFloats);
    for($i=0;$i<$s;$i++)
    {
        $uvCloud[size($uvCloud)] = << $uvFloats[$i], $uvFloats[$i+1], 0 >>;
        $i++;
    }
    
    return $uvCloud;
}

global proc int bcnGetUVCoordCount(string $meshName, string $mapName)
{
    int $cc[] = `polyEvaluate -uvcoord -uvSetName $mapName $meshName`;
    return $cc[0];
}

global proc int bcnGetUVIndex(string $meshName, int $face, int $vIdx, string $mapName)
{
    polyUVSet -cuv -uvSet $mapName;
    int $idx = -1;

    string $vfData[] = `polyListComponentConversion -ff -tvf ($meshName + ".f[" + $face + "]")`;
    $vfData = `ls -flatten $vfData`;

    string $useVF;
    int $i;
    int $uvDS = size($vfData);
    for($i=0; $i<$uvDS; $i++)
    {
        string $chop1[];
        string $chop2[];
        tokenize $vfData[$i] "[" $chop1;
        tokenize   $chop1[1] "]" $chop2;
        
        if(int($chop2[0]) == $vIdx) $useVF = $vfData[$i];
    }

    
    string $uvValue[] = `polyListComponentConversion -fvf -tuv $useVF`;

    if(size($uvValue) > 0 )
    {
        select -r $uvValue[0];
        float $uv[] = `polyEditUV -q -u -v`;
    
        vector $uvmap[] = bcnGetUVMapCloud($meshName, $mapName);
        int $vsize = size($uvmap);
        int $j;
        for($j=0; $j<$vsize; $j++)
        {
            vector $avec = $uvmap[$j];
            if($uv[0] == $avec.x && $uv[1] == $avec.y) $idx = $j;
        }
    }
    
    return $idx;
}

global proc vector[] bcnGetUVCoordPerVertex (string $meshName, string $uvMaps[], int $numOfFaces)
{
    int    $mCount[];
    vector $uvCoords[];
    
    int $i;
    int $s = size($uvMaps);
    for($i=0;$i<$s; $i++)
    {
        $mCount[$i] = 0;

        select -r $meshName;
        polyUVSet -cuv -uvSet $uvMaps[$i];
        
        for($j=0; $j<$numOfFaces; $j++)
        {
            string $vfData[] = `polyListComponentConversion -ff -tvf ($meshName + ".f[" + $j + "]")`;
            $vfData = `ls -flatten $vfData`;

            int $uvi;
            int $uvDS = size($vfData);
            for($uvi=0; $uvi<$uvDS; $uvi++)
            {
                string $uvValue[] = `polyListComponentConversion -fvf -tuv $vfData[$uvi]`;
                int $o;
                int $p = size($uvValue);
                for($o=0; $o<$p; $o++)
                {
                    select -r $uvValue[$o];
                    float  $uv[] = `polyEditUV -q -u -v`;
                    vector $tVec = << $uv[0], $uv[1], 0 >>;
                    $uvCoords[size($uvCoords)] = $tVec;
                     $mCount[$i] = $mCount[$i] + 1;
                }
            }
        }
    }
    
    for($i=0; $i<$s; $i++)
    {
        vector $mVec = << $mCount[$i], 0, 0 >>;
        $uvCoords[size($uvCoords)] = $mVec;
    }
    
    return $uvCoords;
}

global proc vector[] bcnGetNormalsPerVertex(string $meshName, int $vertIdxList[])
{
    vector $normals[];
    
    int $lSize = size($vertIdxList);
    int $i;
    for($i=0; $i<$lSize; $i++)
    {
        if($vertIdxList[$i] != -1)
        {
            string $vtxName = $meshName + ".vtx[" + $i + "]";
            select -r $vtxName;
            string  $pi[] = `polyInfo -vertexToFace`;
            string $pip[];
            tokenize $pi[0] $pip;
            int $pips = size($pip);
                
            int $m;
            int $faceID;
            vector $vNorm = 0;
            vector $fNorm;
                
            string $pi2[];
            string $pip2[];
            for($m=2; $m<$pips; $m++)
            {
                $faceID = $pip[$m];
                   $pi2 = `polyInfo -faceNormals ($meshName + ".f[" + $faceID + "]")`;
                tokenize $pi2[0] $pip2;
                 $fNorm  = << float($pip2[2]), float($pip2[3]), float($pip2[4]) >>;
                 $vNorm += $fNorm;
            }
            $vNorm = `unit $vNorm`;
            $normals[size($normals)] = $vNorm;
        }
    }

    return $normals;
}

global proc vector[] bcnGetNormalsPerFace(string $meshName, int $faceCount)
{
    vector $normals[];
    vector $tNorm;
    
    int $i;
    for($i=0; $i<$faceCount; $i++)
    {
        select -r ($meshName + ".f[" + $i + "]");
        string     $pi[] = `polyInfo -faceNormals`;
        string $nText[];
        
        tokenize $pi[0] $nText;
        
        $tNorm = << float($pi[2]), float($pi[3]), float($pi[4]) >>;
        $normals[size($normals)] = $tNorm;
    }

    return $normals;
}

/***********************************************************/


/////////////////////////////////////////////////////////////
/************************************************************
XML Functions
************************************************************/
/*
global proc string getXmlStartTagNF(string $xmlTagType)
{
    string $tagText = "<" + $xmlTagType + ">";
    return $tagText;
}

global proc string getXmlStartTag(string $xmlTagType, string $xmlFields[], int $isSelfEnding)
{
    string $tagText = "<" + $xmlTagType;
    
    int $i;
    int $s = size($xmlFields);
    for($i=0; $i<$s; $i++) $tagText = $tagText + " " + $xmlFields[$i];
    
    string $tagEnd = ">";
    if($isSelfEnding == 1) $tagEnd = " />";
    $tagText = $tagText + $tagEnd;
    return $tagText;
}

global proc string getXmlEndTag(string $xmlTagType, string $xmlEndComment)
{
    string $tagText = "</" + $xmlTagType + ">";
    if($xmlEndComment != "") $tagText = $tagText + "<!-- " + $xmlEndComment + " -->";
    return $tagText;
}

global proc string getXmlStrField(string $xmlFieldName, string $xmlFieldValue)
{
    string $xmlFieldText = $xmlFieldName + "='" + $xmlFieldValue + "'";
    return $xmlFieldText;
}

global proc string getXmlStrArrField(string $xmlFieldName, string $xmlFieldValues[])
{
    string $xmlFieldText = $xmlFieldName + "='";
    int $i;
    int $s = size($xmlFieldValues);
    for($i=0; $i<$s; $i++)
    {
        $xmlFieldText = $xmlFieldText + "\"" + $xmlFieldValues[$i] + "\"";
        if($i<$s-1) $xmlFieldText = $xmlFieldText + " ";
    }
    $xmlFieldText = $xmlFieldText + "'";
    return $xmlFieldText;
}

global proc string getXmlIntField(string $xmlFieldName, int $xmlFieldValue)
{
    string $xmlFieldText = $xmlFieldName + "='" + $xmlFieldValue + "'";
    return $xmlFieldText;
}

global proc string getXmlIntArrField(string $xmlFieldName, int $xmlFieldValues[])
{
    string $xmlFieldText = $xmlFieldName + "='";
    int $i;
    int $s = size($xmlFieldValues);
    for($i=0; $i<$s; $i++)
    {
        $xmlFieldText = $xmlFieldText + $xmlFieldValues[$i];
        if($i<$s-1) $xmlFieldText = $xmlFieldText + " ";
    }
    $xmlFieldText = $xmlFieldText + "'";

    return $xmlFieldText;
}

global proc string getXmlBoolField(string $xmlFieldName, int $xmlFieldValue)
{
    string $xmlFieldText = $xmlFieldName + "='";
    string $tBool = "true";
    if($xmlFieldValue == 0) $tBool = "false";
    $xmlFieldText = $xmlFieldText + $tBool + "'";
    
    return $xmlFieldText;
}

global proc string getXmlBoolArrField(string $xmlFieldName, int $xmlFieldValues[])
{
    string $xmlFieldText = $xmlFieldName + "='";
    int $i;
    int $s = size($xmlFieldValues);
    for($i=0; $i<$s; $i++)
    {
        string $tBool = "true";
        if($xmlFieldValues[$i] == 0) $tBool = "false";
        $xmlFieldText = $xmlFieldText + $tBool;
        if($i<$s-1) $xmlFieldText = $xmlFieldText + " ";
    }
    $xmlFieldText = $xmlFieldText + "'";
    
    return $xmlFieldText;
}

global proc string getXmlFltField(string $xmlFieldName, float $xmlFieldValue)
{
    string $xmlFieldText = $xmlFieldName + "='" + bcnForceFloat($xmlFieldValue) + "'";
    return $xmlFieldText;
}

global proc string getXmlFltArrField(string $xmlFieldName, float $xmlFieldValues[])
{
    string $xmlFieldText = $xmlFieldName + "='";
    int $i;
    int $s = size($xmlFieldValues);
    for($i=0; $i<$s; $i++)
    {
        $xmlFieldText = $xmlFieldText + bcnForceFloat($xmlFieldValues[$i]);
        if($i<$s-1) $xmlFieldText = $xmlFieldText + " ";
    }
    $xmlFieldText = $xmlFieldText + "'";

    return $xmlFieldText;
}
*/
/***********************************************************/

/////////////////////////////////////////////////////////////
/************************************************************
JSON Functions
************************************************************/
//global proc string getObjectStr(string $bcnObjName)
//{
//}
/*
global proc string getObjHead(string $bcnName)
{
global int $depBxjf;
    string $hd = "\"" + $bcnName + "\":\n";
    
    int $i;
    for($i=0; $i<$depBxjf; $i++) $hd = $hd + "\t";
    $hd = $hd + "{";

    return $hd;
}

global proc string getObjFoot(string $bcnEnd)
{
global int $depBxjf;
    string $ft = "}" + $bcnEnd;
    
    return $ft;
}

global proc string getArrHeadNamed(string $bcnName)
{
global int $depBxjf;
    string $hd = "\"" + $bcnName + "\":\n";
    
    int $i;
    for($i=0; $i<$depBxjf; $i++) $hd = $hd + "\t";
    $hd = $hd + "[";

    return $hd;
}

global proc string getArrHead()
{
global int $depBxjf;
    return "[";
}

global proc string getArrFoot(string $bcnEnd)
{
global int $depBxjf;
    string $ft = "]" + $bcnEnd;
    
    return $ft;
}

global proc string getLeafObj(string $bcnName, string $bcnString[], string $bcnEnd)
{
    string $rStr = "\"" + $bcnName + "\" : {";
    int $i;
    int $a = size($bcnString);
    for($item in $bcnString) $rStr = $rStr + $item;
    $rStr = $rStr + "}" + $bcnEnd;
    
    return $rStr;
}

global proc string getNVPrStr(string $bcnName, string $bcnString, string $bcnEnd)
{
    string $rStr = "\"" + $bcnName + "\" : \"" + $bcnString + "\"" + $bcnEnd;
    return $rStr;
}

global proc string getNVPrStrArr(string $bcnName, int $bcnString[], string $bcnEnd)
{
    string $rStr = "\"" + $bcnName + "\" : [";
    int $i;
    int $a = size($bcnString);
    for($i=0; $i<$a; $i++)
    {
        $rStr = $rStr + "\"" + $bcnString[$i] + "\"";
        if($i < $a-1) $rStr = $rStr + ", ";
        else          $rStr = $rStr + "]" + $bcnEnd;
    }
    
    return $rStr;
}

global proc string getNVPrInt(string $bcnName, int $bcnInt, string $bcnEnd)
{
    string $rStr = "\"" + $bcnName + "\" : " + $bcnInt + $bcnEnd;
    return $rStr;
}

global proc string getNVPrIntArr(string $bcnName, int $bcnInt[], string $bcnEnd)
{
    string $rStr = "\"" + $bcnName + "\" : [";
    int $i;
    int $a = size($bcnInt);
    for($i=0; $i<$a; $i++)
    {
        $rStr = $rStr + $bcnInt[$i];
        if($i < $a-1) $rStr = $rStr + ", ";
        else          $rStr = $rStr + "]" + $bcnEnd;
    }
    
    return $rStr;
}

global proc string bcnForceFloat(float $bcnFloat)
{
    string $fStr = "";
    if(($bcnFloat - floor($bcnFloat)) > 0) $fStr = $fStr + $bcnFloat;
    else                                   $fStr = $fStr + floor($bcnFloat) + ".0";
    
    return $fStr;
}

global proc string getNVPrFlt(string $bcnName, float $bcnFloat, string $bcnEnd)
{
    string $strFloat = bcnForceFloat($bcnFloat);
    string $rStr = "\"" + $bcnName + "\" : " + $strFloat + $bcnEnd;
    return $rStr;
}

global proc string getNVPrFltArr(string $bcnName, float $bcnFloat[], string $bcnEnd)
{
    string $rStr = "\"" + $bcnName + "\" : [";
    int $i;
    int $a = size($bcnFloat);
    for($i=0; $i<$a; $i++)
    {
        string $strFloat = bcnForceFloat($bcnFloat[$i]);
        $rStr = $rStr + $strFloat;
        if($i < $a-1) $rStr = $rStr + ", ";
        else          $rStr = $rStr + "]" + $bcnEnd;
    }
    
    return $rStr;
}

global proc string getNVPrBool(string $bcnName, int $bcnBool, string $bcnEnd)
{
    string  $rStr = "\"" + $bcnName + "\" : ";
    string $tBool = "false";
    if($bcnBool > 0) $tBool = "true";

    $rStr = $rStr + $tBool + $bcnEnd;
    
    return $rStr;
}

global proc string getNVPrBoolArr(string $bcnName, int $bcnBool[], string $bcnEnd)
{
    string $rStr = "\"" + $bcnName + "\" : [";
    int $i;
    int $a = size($bcnBool);
    for($i=0; $i<$a; $i++)
    {
        string $tBool = "false";
        if($bcnBool[$i] > 0) $tBool = "true";
        $rStr = $rStr + $tBool;

        if($i < $a-1) $rStr = $rStr + ", ";
        else          $rStr = $rStr + "]" + $bcnEnd;
    }
        
    return $rStr;
}

global proc string getNVPrNull(string $bcnName, string $bcnEnd)
{
    string $rStr = "\"" + $bcnName + "\" : null" + $bcnEnd;
    return $rStr;
}

global proc string getNVPrNullArr(string $bcnName, int $a, string $bcnEnd)
{
    string $rStr = "\"" + $bcnName + "\" : [";
    int $i;
    for($i=0; $i<$a; $i++)
    {
        if($i < $a-1) $rStr = $rStr + "null, ";
        else          $rStr = $rStr + "null]" + $bcnEnd;
    }
    
    return $rStr;
}

global proc string getNVPrObjArr(string $bcnName, string $bcnString[], string $bcnEnd)
{
    string $rStr = "";
    return $rStr;
}

//global proc string getNamedValuePair(string $bcnName, string $bcnObjName)
//{
//}
*/
/***********************************************************/

/////////////////////////////////////////////////////////////
/************************************************************
Vizor VR Exporter 
************************************************************/
global proc prtVizorMeshBxjf(string $fPath, string $meshName, vector $verts[], vector $norms[], vector $uvs[], int $numOfMaps, int $sIdx)
{
global int $isMayaLtBxjf;
    string $bigString = "";
    printBxjfStatus("Extracting mesh data for " + $meshName);
    $bigString = $bigString + "loadVizorMeshFile({\n";
    $bigString = $bigString + "\t\"idx\":" + $sIdx + ",\n";
    $bigString = $bigString + "\t\"meshname\":\"" + $meshName + "\",\n";
    $bigString = $bigString + "\t\"vertices\":[";
    
    int $uLen = size($uvs);
    int $uBase = $uLen - $numOfMaps;
    
    int $i;
    int $j;
    int $s = size($verts);
    for($i=0; $i<$s; $i++)
    {
        vector $vec = $verts[$i];
        $bigString = $bigString + bcnForceFloat($vec.x) + "," + bcnForceFloat($vec.y) + "," + bcnForceFloat($vec.z);
//        $bigString = $bigString + $verts[$i];
        if($i<$s-1) $bigString = $bigString + ",";
    }
    $bigString = $bigString + "],\n";

    $bigString = $bigString + "\t\"normals\":[";
    $s = size($norms);
    for($i=0; $i<$s; $i++)
    {
        vector $vec = $norms[$i];
        $bigString = $bigString + bcnForceFloat($vec.x) + "," + bcnForceFloat($vec.y) + "," + bcnForceFloat($vec.z);

//        $bigString = $bigString + $norms[$i];
        if($i<$s-1) $bigString = $bigString + ",";
    }
    if($numOfMaps > 0 )
    {
        $bigString = $bigString + "],\n";
        $bigString = $bigString + "\t\"uvLen\":" + $numOfMaps + ",\n";
        
        int $offset = 0;
        for($j=0; $j<$numOfMaps; $j++)
        {
            $bigString = $bigString + "\t\"uv" + $j + "\":[";
            
            vector $bVec = $uvs[$uBase+$j];
            int $epm = int($bVec.x);
            
            int $t;
            for($t=0; $t<$epm; $t++)
            {
                vector $tVec = $uvs[$offset+$t];
                $bigString = $bigString + bcnForceFloat($tVec.x) + "," + bcnForceFloat($tVec.y);
                if($t < $epm-1) $bigString = $bigString + ",";
            }
            
            $bigString = $bigString + "]";
            if($j<$epm-1) $bigString = $bigString + ",\n";
            else          $bigString = $bigString + "\n";
            $offSet = $offset + $epm;
        }
    }
    else            $bigString = $bigString + "]\n";

    $bigString = $bigString + "});";

    if($isMayaLtBxjf == false)
    {
        string $fID= `fopen $fPath`;
        fprint $bigString;
        fclose $fID;
    }
    else fwriteAllText $fPath $bigString;
}

global proc prtVizorHTMLBxjf()
{
global string $vizorHtmlPathBaconXJF;
global string $fPartNoFExt;
global    int $isMayaLtBxjf;
global string $sepBxjf;
global string $bxjfShapes[];
	printBxjfStatus("Writing out Vizor HTML file.");

    string $relScript = getRelativePathToBaconXJF($vizorHtmlPathBaconXJF);
	string $vspScript = $relScript + "js/vizorSceneProcessor.js";

    string $tLine = "<html>\n\t<head>\n";
           $tLine = $tLine + "\t\t<title>BaconXJF 3D Web Formats Exporter - Vizor.io Format</title>\n";
           $tLine = $tLine + "\t\t<script>\n";
           $tLine = $tLine + "\t\t\tvar mdLen = " + size($bxjfShapes) + ";\n";
           $tLine = $tLine + "\t\t\tvar meshData = new Array(mdLen);\n";
           $tLine = $tLine + "\t\t</script>\n";
           $tLine = $tLine + "\t\t<script src=\"" + $relScript + "js/jszip/dist/jszip.js\" type=\"text/javascript\"></script>\n";
           $tLine = $tLine + "\t\t<script src=\"" + $relScript + "js/jszip/vendor/FileSaver.js\" type=\"text/javascript\"></script>\n";
           $tLine = $tLine + "\t</head>\n\t<body>\n";
           $tLine = $tLine + "\t\t<div id=\"content\">Getting Ready! Go again!</div>\n";
           $tLine = $tLine + "\t\t<div id=\"mesharea\">Getting Ready! Go again!</div>\n";
           $tLine = $tLine + "\t\t<canvas id=\"icanvas\"></canvas>\n";
           $tLine = $tLine + "\t\t<script src=\"" + $vspScript + "\"></script>\n";
           for($name in $bxjfShapes) $tLine = $tLine + "\t\t<script src=\"./" + $fPartNoFExt + "_" + $name + ".bcnbtz?callback=loadVizorMeshFile\"></script>\n";
           $tLine = $tLine + "\t\t<script src=\"./" + $fPartNoFExt + ".vzrwrp?callback=processVizorScene\"></script>\n";
           $tLine = $tLine + "\t</body>\n</html>\n";
    
    if($isMayaLtBxjf == false)
    {
        string $vizorHtmlFIDBaconXJF = `fopen $vizorHtmlPathBaconXJF "w"`;
        fprint $vizorHtmlFIDBaconXJF $tLine;
        fclose $vizorHtmlFIDBaconXJF;
    }
    else fwriteAllText $vizorHtmlPathBaconXJF $tLine;
}

global proc float[] sortVizorPtCloud(vector $ptCloud[], int $vIdx[])
{
    printBxjfStatus("Sorting Point Data for Triangle Mesh Export.");
    float $sorted[];
    int $s = size($vIdx);
    int $i;
    for($i=0; $i<$s; $i++)
    {
        if($vIdx[$i] != -1)
        {
            vector $tVec = $ptCloud[$vIdx[$i]];
            $sorted[size($sorted)] = $tVec.x;
            $sorted[size($sorted)] = $tVec.y;
            $sorted[size($sorted)] = $tVec.z;
        }
    }
    return $sorted;
}

global proc writeVzrMaterialsBxjf()
{
global int $depBxjf;
global string $sepBxjf;
global string $vizorHtmlPathBaconXJF;
global string $bxjfShapes[];
global string $expFilePathBaconXJF[];
global string $fPartNoFExt;

    string $mats[];
    string $umats[];
    string $shps[];
    string $cams[];
    string $lits[];
    string $sels[] = `ls -l -shapes -v`;
    int    $slen   = size($sels);
    float  $minBB[] = {0.0, 0.0, 0.0};
    float  $maxBB[] = {0.0, 0.0, 0.0};
    string $uvMaps[];
    
//    $mats = `listConnections -type "shadingEngine" $shps`;
    $mats = `ls -mat`;
    int $mCount = 0;
    for($node in $mats)
    {
        string $matType = `nodeType -api $node`;
        if($matType == "kPhong") $umats[$mCount] = $node;
    }
    
    prtLineBxjf(getObjHead("materials"));
    $depBxjf++;
    int $i = 0;
    for($node in $umats)
    {
        if(`nodeType -api $node` == "kPhong")
        {
		    printBxjfStatus("Exporting Material Node: " + $node + ".\n");
            prtLineBxjf(getObjHead($node));
            $depBxjf++;
    
            string  $trpStr = $node + ".transparency";
            string  $ambStr = $node + ".ambientColor";
            float    $trp[] = `getAttr $trpStr`;
            float     $ac[] = `getAttr $ambStr`;
            float $ambFlt[] = {$ac[0], $ac[1], $ac[2], (1.0-(($trp[0] + $trp[1] + $trp[2])/3.0))};
            prtLineBxjf(getNVPrFltArr("ambient_color", $ambFlt, ","));
            
            float     $dc[] = `getAttr ($node + ".color")`;
            float $difFlt[] = {$dc[0], $dc[1], $dc[2], (1.0-(($trp[0] + $trp[1] + $trp[2])/3.0))};
            prtLineBxjf(getNVPrFltArr("diffuse_color", $difFlt, ","));
            
            int $bfc = 0;
            if(`getAttr ($sels[$i] + ".backfaceCulling")` == 1) $bfc = 1;
            prtLineBxjf(getNVPrBool("double_sided", $bfc, ","));
            
            string $extImage1[] = `defaultNavigation -defaultTraversal -destination ($node+".color")`;
            string $extImage2[] = `defaultNavigation -defaultTraversal -destination ($node+".normalCamera")`;
            int $dmt1 = size($extImage1);
            int $dmt2 = size($extImage2);
            
            int $shinyness = `getAttr ($node + ".reflectivity")`;
            if($dmt1 > 0 || $dmt2 > 0) prtLineBxjf(getNVPrFlt("shinyness", $shinyness, ","));
            else                       prtLineBxjf(getNVPrFlt("shinyness", $shinyness,  ""));
            
            $uvMaps = `polyUVSet -q -auv $sels[$i]`;

            int $di;
            string $iInfo1[];
            for($di=0; $di<$dmt1; $di++)
            {
                int $uvIdx = 0;
                string $uvSetPlug[] = `uvLink -queryObject $sels[$i] -texture $extImage1[$di]`;

                int $fIdx = -1;
                int $cc = size($uvMaps);
                int $cci;
                string $mapName = `getAttr $uvSetPlug[0]`;
                for($cci=0; $cci<$cc; $cci++)
                {
                    if($mapName == $uvMaps[$cci]) $fIdx = $cci;
                }
                
                if($fIdx == -1)
                {
                    $fIdx = $cc;
                    $uvMaps[$cc] = $mapName;
                }

                string $pathAttr = $extImage1[$di] + ".fileTextureName";
                string $extImageFilePath = `getAttr $pathAttr`;
                string $relativePath = getRelativePathToAnotherFile($extImageFilePath, $vizorHtmlPathBaconXJF);
                $iInfo1[size($iInfo1)] = getNVPrStr("url", $relativePath, ",");
                
                if($di<$dmt1-1) $iInfo1[size($iInfo1)] = getNVPrInt("uv_idx", $fIdx, ",");
                else  $iInfo1[size($iInfo1)] = getNVPrInt("uv_idx", $fIdx, "");

            }
            if($dmt1 > 0)
            {
                string $endItem = "";
                if($dmt2 > 0 ) $endItem = ",";
                prtLineBxjf(getLeafObj("diffuse_color_map", $iInfo1, $endItem));
            }
            
            string $iInfo2[];
            for($di=0; $di<$dmt2; $di++)
            {
                int $uvIdx = 0;
                string $uvSetPlug[] = `uvLink -queryObject $sels[$i] -texture $extImage2[$di]`;

                int $fIdx = -1;
                int $cc = size($uvMaps);
                int $cci;
                string $mapName = `getAttr $uvSetPlug[0]`;
                for($cci=0; $cci<$cc; $cci++)
                {
                    if($mapName == $uvMaps[$cci]) $fIdx = $cci;
                }
                
                if($fIdx == -1)
                {
                    $fIdx = $cc;
                    $uvMaps[$cc] = $mapName;
                }

                string $pathAttr = $extImage2[$di] + ".fileTextureName";
                string $extImageFilePath = `getAttr $pathAttr`;
                string $relativePath = getRelativePathToAnotherFile($extImageFilePath, $vizorHtmlPathBaconXJF);
                $iInfo2[size($iInfo2)] = getNVPrStr("url", $relativePath, ",");
                
                if($di<$dmt2-1) $iInfo2[size($iInfo2)] = getNVPrInt("uv_idx", $fIdx, ",");
                else  $iInfo2[size($iInfo2)] = getNVPrInt("uv_idx", $fIdx, "");

            }
            if($dmt2 > 0) prtLineBxjf(getLeafObj("normal_map", $iInfo2, ""));
            $depBxjf--;
        }
        
        string $ender = "";
        if($i < $mCount-1) $ender = ",";
        prtLineBxjf(getObjFoot($ender));
        $i++;
    }
    $depBxjf--;
    prtLineBxjf(getObjFoot(","));
}

global proc writeVzrShapesBxjf()
{
global int $depBxjf;
global string $sepBxjf;
global string $vizorHtmlPathBaconXJF;
global string $bxjfShapes[];
global string $expFilePathBaconXJF[];
global string $fPartNoFExt;

    string $mats[];
    string $umats[];
    string $shps[];
    string $cams[];
    string $lits[];
    string $sels[] = `ls -l -shapes -v`;
    int    $slen   = size($sels);
    float  $minBB[] = {0.0, 0.0, 0.0};
    float  $maxBB[] = {0.0, 0.0, 0.0};
    string $uvMaps[];
    
    int $shCnt = 0;
    for ($node in $sels)
    {
        select -r $node;
        Duplicate;
        Triangulate;
        DeleteHistory;
        string $myChildren[] = `pickWalk -d down `;//listRelatives -children`;
        if(!`attributeExists "bcnco" $myChildren[0]`) addAttr -ln "bcnCloneOf" -sn "bcnco" -dt "string" $myChildren[0];
        
        string $endName[];
        tokenize $node "|" $endName;
        int $enSize = size($endName);
        setAttr ($myChildren[0] + ".bcnco") -type "string" $endName[$enSize-1];
        $shps[$shCnt] = $myChildren[0];
        $shCnt++;
    } 
    
    prtLineBxjf(getObjHead("meshes"));
    $depBxjf++;
    int $count = 0;
    for($node in $shps)
    {
        string $rels[] = `listRelatives -p $shps[$count]`;
        float  $bbs[] = `xform -q -bb $rels[0]`;
        
        if($count == 0)
        {
            $minBB[0] = $bbs[0];
            $minBB[1] = $bbs[1];
            $minBB[2] = $bbs[2];
            $maxBB[0] = $bbs[3];
            $maxBB[1] = $bbs[4];
            $maxBB[2] = $bbs[5];
        }
        else
        {
            if($bbs[0] < $minBB[0]) $minBB[0] = $bbs[0];
            if($bbs[1] < $minBB[1]) $minBB[1] = $bbs[1];
            if($bbs[2] < $minBB[2]) $minBB[2] = $bbs[2];
            if($bbs[3] > $maxBB[0]) $maxBB[0] = $bbs[3];
            if($bbs[4] > $maxBB[1]) $maxBB[1] = $bbs[4];
            if($bbs[5] > $maxBB[2]) $maxBB[2] = $bbs[5];
        }
        
        string $se[] = `listConnections -type "shadingEngine" $shps[$count]`;
        $mats = `defaultNavigation -defaultTraversal -destination ($se[0] + ".surfaceShader")`;
        //string $shapeName = `getAttr ($node + ".bcnco")`;
        $bxjfShapes[$count] = `getAttr ($node + ".bcnco")`;
        
        prtLineBxjf(getObjHead($bxjfShapes[$count]));
        $depBxjf++;
        prtLineBxjf(getArrHeadNamed("batches"));
        $depBxjf++;
        prtLineBxjf "{";
        $depBxjf++;
        prtLineBxjf(getNVPrStr("material",                      $mats[0], ","));  
        prtLineBxjf(getNVPrStr("vertices", ($bxjfShapes[$count] + "_v0"), ","));

        $uvMaps = `polyUVSet -q -auv $node`;

        int $uvms = size($uvMaps);
        
        string $nEnder = "";
        if($uvms > 0) $nEnder = ",";
        prtLineBxjf(getNVPrStr("normals", ($bxjfShapes[$count] + "_n0"), $nEnder));

        if($uvms > 0)
        {
            int $uvmi;
            for($uvmi=0; $uvmi<$uvms; $uvmi++)
            {
                string $uvEnder = "";
                if($uvmi < $uvms-1) $uvEnder = ",";
                prtLineBxjf(getNVPrStr( ("uv" + $uvmi), ($bxjfShapes[$count] + "_t" + $uvmi), $uvEnder ));
            }
        }
        
/*************************************************************************************

global proc  vector[] bcnGetMeshPointCloud   (string $meshName, int       $asWorld)
global proc       int bcnGetPointCount       (string $meshName)
global proc       int bcnGetFaceCount        (string $meshName)
global proc     int[] bcnGetFaceIndexSet     (string $meshName)
global proc  string[] bcnGetUVMapNames       (string $meshName)
global proc       int bcnGetUVMapCount       (string $meshName)
global proc  vector[] bcnGetUVMapCloud       (string $meshName, string    $mapName)
global proc       int bcnGetUVCoordCount     (string $meshName, string    $mapName)
global proc       int bcnGetUVIndex          (string $meshName, int          $face, int $vIdx, string $mapName)
global proc  vecotr[] bcnGetUVCoordPerVertex (string $meshName, string $uvMaps[]);
global proc  vector[] bcnGetNormalsPerVertex (string $meshName, int $vertIdxList[])
global proc  vector[] bcnGetNormalsPerFace   (string $meshName, int     $faceCount)
*************************************************************************************/        

	    printBxjfStatus("Get Face Count for: " + $node);
        int         $numOfFaces =        bcnGetFaceCount($node           );
	    printBxjfStatus("Get Point Count for: " + $node);
        int        $numOfPoints =       bcnGetPointCount($node           );
	    printBxjfStatus("Get Mesh Point Cloud: " + $node);
        vector       $ptCloud[] =   bcnGetMeshPointCloud($node,    true  );
	    printBxjfStatus("Get Vertex Indecies: " + $node);
        int            $vIdxs[] =     bcnGetFaceIndexSet($node           );
	    printBxjfStatus("Sorting Vizor Points: " + $node);
        float      $ptsSorted[] =      sortVizorPtCloud ($ptCloud, $vIdxs);
	    printBxjfStatus("Get Normals Per Vertex: " + $node);
        vector           $npv[] = bcnGetNormalsPerVertex($node,    $vIdxs);
        int                $nom = size($uvMaps);
	    printBxjfStatus("Get UV Map Coordinates: " + $node);
        vector      $uvCoords[] = bcnGetUVCoordPerVertex($node,   $uvMaps, $numOfFaces);
        
/*
        //Get Face Data
        int       $sInfo[] = `polyEvaluate -face $node`;
        int           $nof = $sInfo[0];
        int        $uvSize = size($uvMaps);
        string $faceStrs[];
        string    $verts[];
        string    $norms[];
        string    $uvcds[];
        int       $uvSep[];
        
        //Get indexes of face vertices
        int $j;
        for($j=0; $j<$nof; $j++)
        {
            string $tStr[] = `polyInfo -faceToVertex ($node + ".f[" + $j + "]")`;
            $faceStrs[size($faceStrs)] = $tStr[0];
        }

        //Get position information of vertices
        float $pos[3];
        for($j=0; $j<$nof; $j++)
        {
            string $fPrts[];
            tokenize $faceStrs[$j] $fPrts;
            
            int $fPrtsLen = size($fPrts);
            int $vInFace = $fPrtsLen-2;
            
            int $k;
            for($k=2; $k<$fPrtsLen; $k++)
            {
                int $vtxIdx = $fPrts[$k];
                
                string $vtxName = ($node + ".vtx[" + $vtxIdx + "]");
                $pos = `pointPosition -world $vtxName`;
                int $l;
                for($l=0; $l<3; $l++) $verts[size($verts)] = bcnForceFloat($pos[$l]);
                
                //Calculate the appropriate face normal for this vertecx
                select -r $vtxName;
                string  $pi[] = `polyInfo -vertexToFace`;
                string $pip[];
                tokenize $pi[0] $pip;
                int $pips = size($pip);
                
                int $m;
                int $faceID;
                vector $vNorm = 0;
                vector $fNorm;
                
                string $pi2[];
                string $pip2[];
                for($m=2; $m<$pips; $m++)
                {
                    $faceID = $pip[$m];
                       $pi2 = `polyInfo -faceNormals ($node + ".f[" + $faceID + "]")`;
                       tokenize $pi2[0] $pip2;
                       $fNorm = << float($pip2[2]), float($pip2[3]), float($pip2[4]) >>;
                       $vNorm += $fNorm;
                }
                $vNorm = `unit $vNorm`;
                $norms[size($norms)] = bcnForceFloat($vNorm.x);
                $norms[size($norms)] = bcnForceFloat($vNorm.y);
                $norms[size($norms)] = bcnForceFloat($vNorm.z);
            }
        }
        
        float $tMap[];
        int $n;
        for($n=0; $n<$uvSize; $n++)
        {
            $uvSep[$n] = 0;
            select -r $node;
            polyUVSet -cuv -uvSet $uvMaps[$n];
            print ("UVMap: " + $uvMaps[$n] + "\n");

            for($j=0; $j<$nof; $j++)
            {
                string $vfData[] = `polyListComponentConversion -ff -tvf ($node + ".f[" + $j + "]")`;
                $vfData = `ls -flatten $vfData`;
                int $uvi;
                int $uvDS = size($vfData);
                for($uvi=0; $uvi<$uvDS; $uvi++)
                {
                    string $uvValue[] = `polyListComponentConversion -fvf -tuv $vfData[$uvi]`;
                    int $o;
                    int $p = size($uvValue);
                    for($o=0; $o<$p; $o++)
                    {
                        select -r $uvValue[$o];
                        float $uv[] = `polyEditUV -q -u -v`;
                        $uvcds[size($uvcds)] = $uv[0];
                        $uvSep[$n] = $uvSep[$n] + 1;
                        $uvcds[size($uvcds)] = $uv[1];
                        $uvSep[$n] = $uvSep[$n] + 1;
                    }
                }
            }
        }
*/        
        string $shpFN = $fPartNoFExt + "_" + $bxjfShapes[$count] + ".bcnbtz";
        string $mFilePath = $expFilePathBaconXJF[1] + $sepBxjf + $shpFN;
        
        prtVizorMeshBxjf($mFilePath, $bxjfShapes[$count], $ptsSorted, $npv, $uvCoords, $nom, $count);

        select -r $node;
        string $parent[] = `pickWalk -d up`;
        
        delete $parent[0];
        $depBxjf--;
        prtLineBxjf "}";
        $depBxjf--;
        prtLineBxjf(getArrFoot(""));
        $depBxjf--;
        if($count < $slen-1) prtLineBxjf "},";
        else                 prtLineBxjf "}";
        $count++;
    }
    $depBxjf--;
    prtLineBxjf "},";
    
    prtLineBxjf "\"bounding_box\": ";
    prtLineBxjf "{";
    $depBxjf++;
    prtLineBxjf ("\"lo\": [" + $minBB[0] + ", " + $minBB[1] + ", " + $minBB[2] + "],");
    prtLineBxjf ("\"hi\": [" + $maxBB[0] + ", " + $maxBB[1] + ", " + $maxBB[2] + "],");
    $depBxjf--;
    prtLineBxjf "}";
}
/***********************************************************/
//////////// Vizor VR Exporter End //////////////////////////



/////////////////////////////////////////////////////////////
/***********************************************************
X3D Format Exporter
************************************************************/

global proc string expAnalyzeForX3DLeafBaconXJF(string $gBxjf)
{
    string $myChildren[] = `listRelatives -children $gBxjf`;
    int $cSize = size($myChildren);
    
    if($cSize > 0)
    {
        string $typeName = `nodeType $myChildren[0]`;
        switch($typeName)
        {
            case "directionalLight":
                return "DirectionalLight";
                break;
            case "spotLight":
                return "SpotLight";
                break;
            case "ambientLight": // Is an ambient light, but I haven't figured out yet how to represent it in X3D
                return "PointLight";
                break;
            case "pointLight":
                return "PointLight";
                break;
            case "camera":
                return "Camera";
                break;
            default:
                break;
        }
    }
    
    string $nType = `nodeType $gBxjf`;
    switch($nType)
    {
        case "transform":
            $nType = "Transform";
            break;
//      case "joint":
//          $nType = "";
//          break;
        case "mesh":
            return "Shape";
            break;
        default:
            $nType = "none";
            break;
    }
    
    return $nType;
}

global proc writeX3DDirectionalLight(string $gBxjf, string $cField)
{
global string $bcnFormat[];
global int $expFormatBaconXJF;
global int $depBxjf;
    int $beenUsed = false;
    string $attribute = $gBxjf + ".x3d";
    if(`attributeExists x3d $gBxjf`) $beenUsed = `getAttr $attribute`;
    else
    {
        select -ne $gBxjf;
        addAttr -shortName x3d -longName x3dExported -at bool;
        $beenUsed = true;
        setAttr $gBxjf.x3d -type bool $beenUsed;
    }
    
    string $dlprint = "";
    if($beenUsed == true)
    {
        switch($bcnFormat[$expFormatBaconXJF])
        {
            case "x3dcFileFormat":
                if($cField != "") $dlprint = $cField + " " + "USE " + `getAttr $gBxjf.name`;
                else $dlprint = "USE " + `getAttr $gBxjf.name`;
                prtLineBxjf $dlprint;
                break;
            case "x3djFileFormat":
                if($cField != "")
                {
                    $dlprint = "\"-" + $cField + "\":";
                    prtLineBxjf $dlprint;
                    prtLineBxjf "[";
                    $depBxjf++;
                }            
                prtLineBxjf "{";
                $depBxjf++;
                prtLineBxjf "\"DirectionalLight\":";
                prtLineBxjf "{";
                $depBxjf++;
                string $uString = "\"@USE\":" + "\"" + `getAttr $gBxjf.name` + "\"";
                prtLineBxjf $uString;
                $depBxjf--;
                prtLineBxjf "}";
                $depBxjf--;
                prtLineBxjf "}";
                if($cField != "")
                {
                    $depBxjf--;
                    prtLineBxjf "]";
                }
                break;
            case "x3dxFileFormat":
                string $xmlText = "<DirectionalLight USE=\"" + `getAttr $gBxjf.name` + "\"";
                if($cField != "") $xmlText = $xmlText + " containerField=\"" + $cField + "\"";
                $xmlText = $xmlText + "/>";
                prtLineBxjf $xmlText;
                break;
            case "x3dhFileFormat":
                string $xmlText = "<DirectionalLight USE=\"" + `getAttr $gBxjf.name` + "\"";
                if($cField != "") $xmlText = $xmlText + " containerField=\"" + $cField + "\"";
                $xmlText = $xmlText + "/>";
                prtLineBxjf $xmlText;
                break;            
                 
            default:
                break;
        }
    }
    else
    {
    
        string        $pc[] = `listRelatives -children $gBxjf`;
        string        $catt = $pc[0] + ".color";
         float   $dlColor[] = `getAttr $catt`;
     
        string        $iatt = $pc[0] + ".intensity";
         float    $dlIntens = `getAttr $iatt`;
         if($dlIntens > 1.0) $dlIntens = 1.0;
     
         float  $dlMatrix[] = `xform -q -os -matrix $gBxjf`;
         float $direction[] = {-$dlMatrix[8], -$dlMatrix[9], -$dlMatrix[10]};

         string $x3d_intensity = "";
         if($dlIntens != 0.0 ) $x3d_intensity = "intensity " +  $dlIntens;

         string $x3d_color     = "";
         if($dlColor[0] != 0.0 && $dlColor[1] != 0.0 && $dlColor[2] != 0) $x3d_color = "color " +  $dlColor[0] + " " +  $dlColor[1] + " " +  $dlColor[2];
     
         string $x3d_direction = "";      
         if($direction[0] != 0.0 && $direction[1] != 0.0 && $direction[2] != 0) $x3d_direction = "direction " +  $direction[0] + " " +  $direction[1] + " " +  $direction[2];
     
        switch($bcnFormat[$expFormatBaconXJF])
        {
            case "x3dcFileFormat":
                string $clString = "";
                if($cField != "") $clString = $cField + " DEF " + $gBxjf + " DirectionalLight";
                else $clString = "DEF " + $gBxjf + " DirectionalLight";
                if($x3d_intensity != "" || $x3d_color != "" || $x3d_direction != "")
                {
                    prtLineBxjf $clString;
                    prtLineBxjf "{";
                    $depBxjf++;
                    if($x3d_intensity != "") prtLineBxjf $x3d_intensity;
                    if($x3d_color     != "") prtLineBxjf $x3d_color;
                    if($x3d_direction != "") prtLineBxjf $x3d_direction;
                    $depBxjf--;
                    prtLineBxjf "}";
                }
                else
                {
                    $clString = $clString + "{}";
                    prtLineBxjf $clString;
                }
                break;
            case "x3djFileFormat":
                break;
            case "x3dxFileFormat":
                break;
            case "x3dhFileFormat":
                break;
            default:
                break;
        }
    }
}
         
global proc writeX3DSpotLight(string $gBxjf, string $cf)
{
global int $depBxjf;

}

global proc writeX3DPointLight(string $gBxjf, string $cf)
{
global int $depBxjf;

}

global proc writeX3DShapeBranch(string $gBxjf, string $cf)
{
global int $depBxjf;

}

global proc writeX3DTransformBranch(string $gBxjf, string $cf)
{
global int $depBxjf;
global string $expListBxjf[];
    $depBxjf++;
    if(!`attributeExists "bcnco" $gBxjf`)
    {
        addAttr -ln "bcnCloneOf" -sn "bcnco" -dt "string" $gBxjf;
        setAttr ($gBxjf + ".bcnco") -type "string" $gBxjf;
        $expListBxjf[size($expListBxjf)] = $gBxjf;
        
        string $nf[];
        $nf[size($nf)] = getXmlStrField("DEF", $gBxjf);
        if($cf != "") $nf[size($nf)] = getXmlStrField("containerField", $cf);
        
        prtLineBxjf(getXmlStartTag("Transform", $nf, false));
        prtLineBxjf(getXmlEndTag("Transform", ""));
    }
    else
    {
        string $nf[];
        $nf[size($nf)] = getXmlStrField("USE", $gBxjf);
        if($cf != "") $nf[size($nf)] = getXmlStrField("containerField", $cf);
        
        prtLineBxjf(getXmlStartTag("Transform", $nf, true));
    }

}

global proc writeX3DLODBranch(string $gBxjf, string $cf)
{
global int $depBxjf;

}

global proc writeX3dxMaterialsBxjf()
{
global int $depBxjf;

}

global proc traverseSGx3dBaconXJF(string $gBxjf, string $branchNameBxjf, int $identity)
{
global int $isMayaLtBxjf;
//global int $depBxjf;
//    $depBxjf++;
    int $expIdx  = -1;
    int $ebSize  =  0;
    int $iExpIdx =  0;
    string $myChildren[] = `listRelatives -children $gBxjf`;
    
    string $nodeType = expAnalyzeForX3DLeafBaconXJF($gBxjf);
    print $nodeType;
    switch($nodeType)
    {
        //Is Transform with Light Leaf
        case "DirectionalLight":
            writeX3DDirectionalLight($gBxjf, "");
            break;
                    
        case "SpotLight":
            writeX3DSpotLight($gBxjf, "");
            break;

        case "PointLight":
            writeX3DPointLight($gBxjf, "");
            break;
                
//                case "AmbientLight":
//                    $sgUUID = getUUIDBaconXJF($gBxjf);
//                    $tempLine = "\"uuid\": \"" + $sgUUID + "\"";
//                    prtLineBxjf $tempLine;
//                    break;

        case "Shape":
            writeX3DShapeBranch($gBxjf, "");
            break;

        //Default is Standard Transform Node
        case "Transform":
            writeX3DTransformBranch($gBxjf, "");
            break;

        case "LOD":
            writeX3DLODBranch($gBxjf, "");
            break;
//        case "joint":
//            string $pjoint = $nodeTypeBxjf + ":" + $gBxjf + ":" + genUUIDBaconXJF();
//            prtLineBxjf $pjoint;
//            for($aChild in $myChildren) traverseSGthreejsBaconXJF($aChild, "", 0);
//            break;

        default:
//            string $pdefault = $nodeTypeBxjf + ":" + $gBxjf + ":" + genUUIDBaconXJF();
//            prtLineBxjf $pdefault;
            break;
    }
    
    
}

/**********************************************************/
/////// X3D EXPORTER End ///////////////////////////////////
////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////
/***********************************************************
ThreeJS Format Exporter
***********************************************************/
global proc string expAnalyzeForThreeJSLeafBaconXJF(string $gBxjf)
{
    string $myChildren[] = `listRelatives -children $gBxjf`;
    if(size($myChildren) == 0) return "Object3D";
    
    string $typeName = `nodeType $myChildren[0]`;
    switch($typeName)
    {
        case "directionalLight":
            return "DirectionalLight";
            break;
        case "spotLight":
            return "SpotLight";
            break;
        case "ambientLight":
            return "AmbientLight";
            break;
        case "pointLight":
            return "PointLight";
            break;
        case "camera":
            return "Camera";
            break;
        case "mesh":
            return "Mesh";
            break;
    }
}

global proc string getHexBaconXJF(int $num)
{
    string $strVal = "";
    switch($num)
    {
        case 10:
            $strVal = $strVal + "a";
            break;
        case 11:
            $strVal = $strVal + "b";
            break;
        case 12:
            $strVal = $strVal + "c";
            break;
        case 13:
            $strVal = $strVal + "d";
            break;
        case 14:
            $strVal = $strVal + "e";
            break;
        case 15:
            $strVal = $strVal + "f";
            break;
        default:
            $strVal = $strVal + $num;
            break;
    }
    return $strVal;
}

global proc string genUUIDPartBaconXJF(float $cTime, string $c)
{
    int $r = ($cTime + (`rand 1` * 16)) % 16;

    string $strVal = "";
    if($c=="x") $strVal = getHexBaconXJF($r);
    else
    {
        if($r>7) $r = $r-8;
        $r = $r + 8;
        $strVal = getHexBaconXJF($r);
    }
    return $strVal;
}

global proc string genUUIDBaconXJF()
{
    float $cTime = `currentTime -query`;
    string $uuid = "";
    string $rText = "";
    for($i=0; $i<6; $i++)
    {
        $rText = genUUIDPartBaconXJF($cTime, "x");
        $uuid = $uuid + $rText;
        $cTime = $cTime / 16;
    }
    $uuid = $uuid + "-";
    for($i=0; $i<4; $i++)
    {
        $rText = genUUIDPartBaconXJF($cTime, "x");
        $uuid = $uuid + $rText;
        $cTime = $cTime / 16;
    }
    $uuid = $uuid + "-4";
    for($i=0; $i<3; $i++)
    {
        $rText = genUUIDPartBaconXJF($cTime, "x");
        $uuid = $uuid + $rText;
        $cTime = $cTime / 16;
    }
    $uuid = $uuid + "-";
    $rText = genUUIDPartBaconXJF($cTime, "y");
    $uuid = $uuid + $rText;
    $cTime = $cTime / 16;
    for($i=0; $i<3; $i++)
    {
        $rText = genUUIDPartBaconXJF($cTime, "x");
        $uuid = $uuid + $rText;
        $cTime = $cTime / 16;
    }
    $uuid = $uuid + "-";
    for($i=0; $i<12; $i++)
    {
        $rText = genUUIDPartBaconXJF($cTime, "x");
        $uuid = $uuid + $rText;
        $cTime = $cTime / 16;
    }
    
    return $uuid;
}

global proc string getUUIDBaconXJF(string $gBxjf)
{
global string $expBxjfMName[];
global string $expBxjfID[];

    int $expIdx = -1;
    int $ebSize = size($expBxjfMName);
    int $iExpIdx = 0;
    while($expIdx < 0 && $iExpIdx < $ebSize)
    {
        if($gBxjf == $expBxjfMName[$iExpIdx]) $expIdx = $iExpIdx;
        $iExpIdx++;
    }
    string $lUUID = "";
    if($expIdx == -1)
    {
        $expIdx = $ebSize;
        $lUUID = genUUIDBaconXJF();
        $expBxjfID[$expIdx] = $lUUID;
        $expBxjfMName[$expIdx] = $gBxjf;
    }
    else $lUUID = $expBxjfID[$expIdx];
    return $lUUID;
}

global proc waosBxjf()
{
global int $depBxjf;
    prtLineBxjf "{";
    $depBxjf++;    
}

global proc wacsBxjf()
{
global int $depBxjf;
    prtLineBxjf "}";
    $depBxjf--;        
}

global proc wacswcBxjf()
{
global int $depBxjf;
    prtLineBxjf "},";
    $depBxjf--;
}

global proc writeThreejsMesh(string $gBxjf, string $myChildren[], int $prtComma)
{
global int $depBxjf;
    //ToDo - Write out transform attributes
    string $sgUUID = getUUIDBaconXJF($gBxjf);
                    
    waosBxjf();                    
    string $ptrans = "\"uuid\": \"" + $sgUUID + "\",";
    prtLineBxjf $ptrans;
                    
    $ptrans = "\"type\": \"Mesh\",";
    prtLineBxjf $ptrans;
                    
    $ptrans = "\"name\": \"" + $gBxjf + "\"";
                    
    if(size($myChildren) > 1)
    {
        $ptrans = $ptrans + ",";
        prtLineBxjf $ptrans;
        $ptrans = "\"children\":";
        prtLineBxjf $ptrans;
                    
        prtLineBxjf "[";
               
        //Traverse Children
        for($idx=1; $idx<size($myChildren); $idx++)
        {
            int $hmc = 0;
            int $myCheck = size($myChildren);
            $myCheck = $myCheck-1;
            if($idx < $myCheck) $hmc = 1;
            int $idt = 0;
            traverseSGthreejsBaconXJF($myChildren[$idx], $hmc);   
        }
                        
        prtLineBxjf "]";
    }
    else prtLineBxjf $ptrans;
                    
    $depBxjf--;
    if($prtComma == 1) wacswcBxjf();
    else wacsBxjf();
}


//ThreeJS
global proc traverseSGthreejsBaconXJF(string $gBxjf, int $prtComma)
{
global int $isMayaLtBxjf;
global int $depBxjf;
    $depBxjf++;
    int $expIdx  = -1;
    int $ebSize  =  0;
    int $iExpIdx =  0;
    string $myChildren[] = `listRelatives -children $gBxjf`;
    string $nodeTypeBxjf = `nodeType $gBxjf`;
    
    string $sgUUID = "";
    switch($nodeTypeBxjf)
    {
        case "lodGroup":
            break;
        case "transform":
            string $leafTypeBxjf = expAnalyzeForThreeJSLeafBaconXJF($gBxjf);
            
            switch($leafTypeBxjf)
            {
                //Is Transform with Light Leaf
                case "DirectionalLight":
                    $sgUUID = getUUIDBaconXJF($gBxjf);
                    $tempLine = "\"uuid\": \"" + $sgUUID + "\"";
                    prtLineBxjf $tempLine;
                    break;
                    
                case "SpotLight":
                    $sgUUID = getUUIDBaconXJF($gBxjf);
                    $tempLine = "\"uuid\": \"" + $sgUUID + "\"";
                    prtLineBxjf $tempLine;
                    break;

                case "PointLight":
                    $sgUUID = getUUIDBaconXJF($gBxjf);
                    $tempLine = "\"uuid\": \"" + $sgUUID + "\"";
                    prtLineBxjf $tempLine;
                    break;
                
                case "AmbientLight":
                    $sgUUID = getUUIDBaconXJF($gBxjf);
                    $tempLine = "\"uuid\": \"" + $sgUUID + "\"";
                    prtLineBxjf $tempLine;
                    break;
//                case "Mesh":
//                    writeThreejsMeshBaconXTF($gBxtf, $myChildren, $prtComma);
//                    break;
                                        
                case "Mesh":
                    writeThreejsMesh($gBxjf, $myChildren, $prtComma);
                    break;

                //Default is Standard Transform Node
                case "Object3D":
                    //ToDo - Write out transform attributes
                    $sgUUID = getUUIDBaconXJF($gBxjf);
                    string $ptrans = $leafTypeBxjf + ":" + $gBxjf + ": \"" + $sgUUID + "\"";
                    prtLineBxjf $ptrans;
                    //Traverse Children
                    for($aIdx=1; $aIdx<size($myChildren); $aIdx++)
                    {
                        int $hmc = 0;
                        int $myCheck = size($myChildren);
                        $myCheck = $myCheck-1;
                        if($aIdx < $myCheck) $hmc = 1;
                        int $idt = 0;
                        traverseSGthreejsBaconXJF($myChildren[$aIdx], $hmc);   
                    }
                    break;
            }
            break;
//        case "joint":
//            string $pjoint = $nodeTypeBxjf + ":" + $gBxjf + ":" + genUUIDBaconXJF();
//            prtLineBxjf $pjoint;
//            for($aChild in $myChildren) traverseSGthreejsBaconXJF($aChild, "", 0);
            break;
        default:
//            string $pdefault = $nodeTypeBxjf + ":" + $gBxjf + ":" + genUUIDBaconXJF();
//            prtLineBxjf $pdefault;
            break;
    }
}

/********************************************************************/
///////// ThreeJS Exporter End ///////////////////////////////////////


//////////////////////////////////////////////////////////////////////
/*********************************************************************
glTF exporter
*********************************************************************/
//glTF
global proc traverseSGgltfBaconXJF(string $gBxjf, string $branchNameBxjf, int $identity)
{
global int $depBxjf;
    $depBxjf++;    
    
}
/********************************************************************/
//////////// glTF Exporter End ///////////////////////////////////////

global proc prtLineBxjf(string $bftxLine)
{
global int $expFileIdBaconXJF;
global string $expFilePathBaconXJF[];
global int $depBxjf;
global int $isMayaLtBxjf;
global int $depOffsetBxjf;
global string $expStrBaconXJF[];

    string $tLine = "";
     
    for($i=0; $i<$depBxjf; $i++) $tLine = "\t"+$tLine;
    $tLine = $tLine + $bftxLine;
    if($isMayaLtBxjf == false)
    {
        $tLine = $tLine + "\n";
        fprint $expFileIdBaconXJF $tLine;
    }
    else $expStrBaconXJF[size($expStrBaconXJF)] = $tLine;
}

global proc writeFileHeaderBaconXJF()
{
global int $expFormatBaconXJF;
global string $expFilePathBaconXJF[];
global int $depBxjf;
global int $depOffsetBxjf;
global string $bxjfType;
global string $bcnFormat[];

    switch($bcnFormat[$expFormatBaconXJF])
    {
        case "bcnFileFormat":
            break;
        case "vzrFileFormat":
            $bxjfType = "Vizor";
            prtLineBxjf "processVizorScene({";
            break;
        case "gltfFileFormat":
            $bxjfType = "Gltf";
            prtLineBxjf "{";
            break;
        case "tjsFileFormat":
            $bxjfType = "Threejs";
            prtLineBxjf "{";
            break;
        case "x3dcFileFormat":
            $bxjfType = "X3DC";
            prtLineBxjf "#X3D V3.0 utf8";
            prtLineBxjf "PROFILE Interchange";
            break;
        case "x3djFileFormat":
            $bxjfType = "X3DJ";
            prtLineBxjf "[";
            $depBxjf++;
            prtLineBxjf "{";
            $depBxjf++;
            prtLineBxjf "\"X3D\":";
            prtLineBxjf "{";
            $depBxjf++;
            prtLineBxjf "\"@profile\":\"Interchange\",";
            prtLineBxjf "\"@version\":3.3,";
            prtLineBxjf "\"@xsd:noNamespaceSchemaLocation\":\"http://www.web3d.org/specifications/x3d-3.3.xsd\"";
            break;
        case "x3dxFileFormat":
            $bxjfType = "X3DX";
            prtLineBxjf "<?xml version=\"1.0\" encoding=\"utf-8\"?>";
            prtLineBxjf "<!DOCTYPE X3D PUBLIC \"ISO//Web3D//DTD X3D 3.0//EN\"  \"http://www.web3d.org/specifications/x3d-3.0.dtd\">";
            string $x3dArray[];
            $x3dArray[size($x3dArray)] = getXmlFltField("version", 3.0);
            $x3dArray[size($x3dArray)] = getXmlStrField("profile", "Interchange");
            prtLineBxjf(getXmlStartTag("X3D", $x3dArray, false));
            break;
        case "x3dhFileFormat":
            $bxjfType = "X3DH";
            prtLineBxjf "<?xml version=\"1.0\" encoding=\"utf-8\"?>";
            prtLineBxjf "<!DOCTYPE X3D PUBLIC \"ISO//Web3D//DTD X3D 3.0//EN\"  \"http://www.web3d.org/specifications/x3d-3.0.dtd\">";
            string $x3dArray[];
            $x3dArray[size($x3dArray)] = getXmlFltField("version", 3.0);
            $x3dArray[size($x3dArray)] = getXmlStrField("profile", "Interchange");
            prtLineBxjf(getXmlStartTag("X3D", $x3dArray, false));
            break;
        default:
            prtLineBxjf "Failure Start";
            break;
    }
}

global proc writeMetadataBaconXJF()
{
global string $expFilePathBaconXJF[];
global string $matsBxjf[];
global string $meshBxjf[];
global int $expFormatBaconXJF;
global int $depBxjf;
global int $matSizeBxjf;
global string $fPartsBxjf[];
global string $fPartNoFExt;
global string $bcnFormat[];


    $matsBxjf = `ls -mat`;
    string $pcBxjf[] = `ls -type "particleCloud"`;
    string $cgfxShader[] = `ls -type "cgfxShader"`;
    string $occShader[] = `ls -type "ilrOccSampler"`;
    $matSizeBxjf = size($matsBxjf) - size($pcBxjf) - size($cgfxShader) - size($occShader);

//    string $phongs[] = `ls -type phong`;
//    string $shdrfx[] = `ls -type ShaderfxShader`;
    
//    for($idx = 0; $idx<size($phongs); $idx++) $matsBxjf[size($matsBxjf)] = $phongs[$idx];
//    for($idx = 0; $idx<size($shdrfx); $idx++) $matsBxjf[size($matsBxjf)] = $shdrfx[$idx];
    
    $meshBxjf = `ls -type mesh`;
    
    int $vertNum = 0;
    int $faceNum = 0;
    int $normNum = 0;
    int $colorNum = 0;
    int $uvNum = 0;
    
    int $ctNums[];
    
    for($meshIdx in $meshBxjf)
    {
        $ctNums  = `polyEvaluate -v -f -uv $meshIdx`;
        $vertNum = $vertNum + $ctNums[0];
        $faceNum = $faceNum + $ctNums[1];
        $uvNum   = $uvNum   + $ctNums[2];
//        string $values = "Verts: " + $vertNum + ", Faces: " + $faceNum + ", UVs: " + $uvNum + "\n";
//        print $values;
    }
        
    string $tMetaLine = "";

    switch($bcnFormat[$expFormatBaconXJF])
    {
        case "vzrFileFormat":
            int $len = size($fPartsBxjf);
            $depBxjf++;
            string $metaData = "\"id\": \"" + $fPartNoFExt + "_json\",";
            prtLineBxjf $metaData;
            break;
        case "gltfFileFormat":
//            prtLineBxjf "{";
            break;
        case "tjsFileFormat":
            $depBxjf++;
            prtLineBxjf "\"metadata\":";
            prtLineBxjf "{";
            //
            $depBxjf++;
            
            $tMetaLine = "\"sourceFile\": \"" + `file -q -sn` + "\"";
            prtLineBxjf $tMetaLine;
            
            prtLineBxjf "\"generatedBy\": \"MayaLT 2015 - Using: BaconXJF\",";
            
            $tMetaLine = "\"vertices\": " + $vertNum + ",";
            prtLineBxjf $tMetaLine;
            
            $tMetaLine = "\"faces\": " + $faceNum + ",";
            prtLineBxjf $tMetaLine;
            
            $tMetaLine = "\"normals\": " + $normNum + ",";
            prtLineBxjf $tMetaLine;
            
            $tMetaLine = "\"colors\": " + $colorNum + ",";
            prtLineBxjf $tMetaLine;
            
            $tMetaLine = "\"uvs\": " + $uvNum + ",";
            prtLineBxjf $tMetaLine;
            
            $tMetaLine = "\"materials\": " + $matSizeBxjf;
            prtLineBxjf $tMetaLine;

            $depBxjf--;
            //
            prtLineBxjf "},";
            $depBxjf--;
            break;
        case "x3dcFileFormat":
            string $metaInfo =  "META \"filename\" \"" + $expFilePathBaconXJF[2] + "\"";
            prtLineBxjf $metaInfo;
            break;
        case "x3djFileFormat":
            prtLineBxjf "\"head\":";
            prtLineBxjf "[";
            $depBxjf++;
            prtLineBxjf "{";
            $depBxjf++;
            prtLineBxjf "\"meta\":";
            prtLineBxjf "{";
            $depBxjf++;
            string $metaInfo = "\"@content\":\"" + $expFilePathBaconXJF[2] + "\",";
            prtLineBxjf $metaInfo;
            prtLineBxjf "\"@name\":\"filename\"";
            $depBxjf--;
            prtLineBxjf "}";
            $depBxjf--;
            prtLineBxjf "}";
            $depBxjf--;
            prtLineBxjf "],";
            break;
        case "x3dxFileFormat":
            $depBxjf++;
            string $empty[];
            string $x3dString = getXmlStartTagNF("head");
            prtLineBxjf($x3dString);
            
            $depBxjf++;
            string $x3dArray[];
            $x3dArray[size($x3dArray)] = getXmlStrField("name", "filename");
            $x3dArray[size($x3dArray)] = getXmlStrField("content", $expFilePathBaconXJF[2]);
            prtLineBxjf(getXmlStartTag("meta", $x3dArray, true));
            
            $depBxjf--;
            prtLineBxjf(getXmlEndTag("head",""));
            break;
        case "x3dhFileFormat":
            $depBxjf++;
            string $empty[];
            prtLineBxjf(getXmlStartTagNF("head"));
            
            $depBxjf++;
            string $x3dArray[];
            $x3dArray[size($x3dArray)] = getXmlStrField("name", "filename");
            $x3dArray[size($x3dArray)] = getXmlStrField("content", $expFilePathBaconXJF[2]);
            prtLineBxjf(getXmlStartTag("meta", $x3dArray, true));
            
            $depBxjf--;
            prtLineBxjf(getXmlEndTag("head",""));
            break;
        default:
            prtLineBxjf "Failure Start";
            break;
    }
    
}

global proc writeMaterialsBaconXJF()
{
global string $matsBxjf[];
global int $matSizeBxjf;
global int $expFormatBaconXJF;
global int $depBxjf;
global string $expBxjfMName[];
global string $expBxjfID[];
global string $bcnFormat[];

    int $expIdx  = -1;
    int $ebSize  =  0;
    int $iExpIdx =  0;
    string $tempLine = "";
    int $cCount = 0;
    switch($bcnFormat[$expFormatBaconXJF])
    {
        case "vzrFileFormat":
            writeVzrMaterialsBxjf();
            break;
        case "tjsFileFormat":
            $depBxjf++;
            $tempLine = "\"materials\":";
            prtLineBxjf $tempLine;
            prtLineBxjf "[";
            $depBxjf++;
            
            for($mIdx=0; $mIdx<size($matsBxjf); $mIdx++)
            {
                string $tType = `nodeType $matsBxjf[$mIdx]`;
                switch($tType)
                {
                    case "phong":
                        prtLineBxjf "{";
                        $depBxjf++;
                        $cCount++;

                        string $phUUID = getUUIDBaconXJF($matsBxjf[$mIdx]);
                        
                        $tempLine = "\"uuid\": \"" + $phUUID + "\"";
                        prtLineBxjf $tempLine;
                        
                        $tempLine = "\"type\": \"MeshPhongMaterial\"";
                        prtLineBxjf $tempLine;
                        
                        $depBxjf--;
                        $tempLine = "}";
                        if($cCount != $matSizeBxjf) $tempLine = $tempLine + ",";
                        prtLineBxjf $tempLine;
                        break;
                    case "lambert":
                        prtLineBxjf "{";
                        $depBxjf++;
                        $cCount++;

                        string $laUUID = getUUIDBaconXJF($matsBxjf[$mIdx]);
                        
                        $tempLine = "\"uuid\": \"" + $laUUID + "\"";
                        prtLineBxjf $tempLine;
                        
                        $tempLine = "\"type\": \"MeshLambertMaterial\"";
                        prtLineBxjf $tempLine;
                        
                        $depBxjf--;
                        $tempLine = "}";
                        if($cCount != $matSizeBxjf) $tempLine = $tempLine + ",";
                        prtLineBxjf $tempLine;
                        break;
                    case "ShaderfxShader":
                        prtLineBxjf "{";
                        $depBxjf++;
                        $cCount++;

                        string $sfxUUID = getUUIDBaconXJF($matsBxjf[$mIdx]);
                        
                        $tempLine = "\"uuid\": \"" + $sfxUUID + "\"";
                        prtLineBxjf $tempLine;
                        
                        $tempLine = "\"type\": \"MeshBasicMaterial\"";
                        prtLineBxjf $tempLine;
                        
                        $depBxjf--;
                        $tempLine = "}";
                        if($cCount != $matSizeBxjf) $tempLine = $tempLine + ",";
                        prtLineBxjf $tempLine;
                        break;
                    default:
                        break;
                }
            }
            $depBxjf--;
            prtLineBxjf "],";
            $depBxjf--;
            break;
        case "x3dxFileFormat":
            writeX3dxMaterialsBxjf();
            break;
        case "x3dhFileFormat":
            writeX3dxMaterialsBxjf();
            break;
        default:
            break;
    }
}

global proc writeTexturesBaconXJF()
{
}

global proc writeSceneGraphBaconXJF()
{
global string $sgGroups[];
global int $expFormatBaconXJF;
global int $depBxjf;
global string $bcnFormat[];

    int $size = size($sgGroups);
    switch($bcnFormat[$expFormatBaconXJF])
    {
        
        case "vzrFileFormat":
            writeVzrShapesBxjf();
            break;
        case "gltfFileFormat":
            for($i=0;$i<$size;$i++) traverseSGgltfBaconXJF($sgGroups[$i], "", 0);
            break;
        case "tjsFileFormat":
            $depBxjf++;
            string $tempBxjf = "";
            $tempBxjf = "\"object\":";
            prtLineBxjf $tempBxjf;
            prtLineBxjf "{";
                
            $depBxjf++;
                
            $tempBxjf = "\"uuid\": \"" + genUUIDBaconXJF() + "\",";
            prtLineBxjf $tempBxjf;
                
            $tempBxjf = "\"type\": \"Scene\",";
            prtLineBxjf $tempBxjf;
                
            $tempBxjf = "\"matrix\": [1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],";
            prtLineBxjf $tempBxjf;
                
            $tempBxjf = "\"children\": ";
            prtLineBxjf $tempBxjf;
            prtLineBxjf "[";
                
            for($i=0;$i<$size;$i++)
            {
                int $hmc = 0;
                int $myCheck = $size-1;
                if($i < $myCheck) $hmc = 1;
                traverseSGthreejsBaconXJF($sgGroups[$i], $hmc);
            }
            prtLineBxjf "]";
            $depBxjf--;
            prtLineBxjf "}";
            $depBxjf--;
            break;
        case "x3dcFileFormat":
            for($i=0;$i<$size;$i++)
            {
                print "It was called.";
                   traverseSGx3dBaconXJF($sgGroups[$i], "", 0);
                   $depBxjf--;
            }
            break;        
        case "x3djFileFormat":
            prtLineBxjf "\"Scene\":";
            prtLineBxjf "[";
            for($i=0;$i<$size;$i++)
            {
                traverseSGx3dBaconXJF($sgGroups[$i], "", 0);
                $depBxjf--;
            }
            prtLineBxjf "]";
            break;        
        case "x3dxFileFormat":
            prtLineBxjf(getXmlStartTagNF("Scene"));
            for($i=0;$i<$size;$i++)
            {
                traverseSGx3dBaconXJF($sgGroups[$i], "", 0);
                $depBxjf--;
            }
            prtLineBxjf(getXmlEndTag("Scene",""));
            break;
        case "x3dhFileFormat":
            prtLineBxjf(getXmlStartTagNF("Scene"));
            for($i=0;$i<$size;$i++)
            {
                traverseSGx3dBaconXJF($sgGroups[$i], "", 0);
                $depBxjf--;
            }
            prtLineBxjf(getXmlEndTag("Scene",""));
            break;
        default:
            break;
    }        
}

global proc writeFileFooterBaconXJF()
{
global int $expFormatBaconXJF;
global int $expFileIdBaconXJF;
global int $depBxjf;
global string $bcnFormat[];

    switch($bcnFormat[$expFormatBaconXJF])
    {
        case "vzrFileFormat":
            $depBxjf--;
            prtLineBxjf "});";
            break;
        case "gltfFileFormat":
            prtLineBxjf "}";
            break;
        case "tjsFileFormat":
            prtLineBxjf "}";
            break;
        case "x3dcFileFormat":
            break;
        case "x3djFileFormat":
            $depBxjf--;
            prtLineBxjf "}";
            $depBxjf--;
            prtLineBxjf "}";
            $depBxjf--;
            prtLineBxjf "]";
            break;
        case "x3dxFileFormat":
            $depBxjf--;
            prtLineBxjf(getXmlEndTag("X3D",""));
            break;        
        case "x3dhFileFormat":
            $depBxjf--;
            prtLineBxjf(getXmlEndTag("X3D",""));
            break;        
        default:
            prtLineBxjf "Failure End";
            break;
    }    
}

global proc expSelBaconXJF()
{
global int $expFormatBaconXJF;
global string $expFilePathBaconXJF[];
global int $expFileIdBaconXJF;
global int $depBxjf;
global int $isMayaLtBxjf;
global string $expStrBaconXJF[];
global int $isSelectBxjf;
global string $sgGroups[];
global string $expBxjfMName[];
global string $expBxjfID[];
global string $fPartsBxjf[];
global string $fPartNoFExt;
global string $vizorHtmlPathBaconXJF;
global string $sepBxjf;
global string $bcnFormat[];
global string $expListBxjf[];

    int $selItems[] = `textScrollList -query -sii "bftxTSL"`;
    
    $expFormatBaconXJF = $selItems[0]-1;
    
    switch($bcnFormat[$expFormatBaconXJF])
    {
        case "bcnFileFormat":
            $expFilePathBaconXJF = `fileDialog2 -fm 0 -cap "Export Bacon Wrap" -ff "Bacon Wrap (*.bcnwrp)" -okc "Save" -cc "Cancel"`;
            break;
        case "vzrFileFormat":
            $expFilePathBaconXJF = `fileDialog2 -fm 0 -cap "Export Vizor VR" -ff "Vizor VR (*.vzrwrp)" -okc "Save" -cc "Cancel"`;
            break;
        case "gltfFileFormat":
            $expFilePathBaconXJF = `fileDialog2 -fm 0 -cap "Export glFT" -ff "glFT (*.json)" -okc "Save" -cc "Cancel"`;
            break;
        case "tjsFileFormat":
            $expFilePathBaconXJF = `fileDialog2 -fm 0 -cap "Export ThreeJS" -ff "ThreeJS (*.json)" -okc "Save" -cc "Cancel"`;
            break;
        case "x3dcFileFormat":
            $expFilePathBaconXJF = `fileDialog2 -fm 0 -cap "Export X3D Classic" -ff "X3D Classic (*.x3dv)" -okc "Save" -cc "Cancel"`;
            break;
        case "x3djFileFormat":
            $expFilePathBaconXJF = `fileDialog2 -fm 0 -cap "Export X3D xml" -ff "X3D JSON (*.json)" -okc "Save" -cc "Cancel"`;
            break;
        case "x3dxFileFormat":
            $expFilePathBaconXJF = `fileDialog2 -fm 0 -cap "Export X3D xml" -ff "X3D xml (*.x3d)" -okc "Save" -cc "Cancel"`;
            break;
        case "x3dhFileFormat":
            $expFilePathBaconXJF = `fileDialog2 -fm 0 -cap "Export XHTML" -ff "XHMTL (*.html)" -okc "Save" -cc "Cancel"`;
            break;
        default:
            $expFilePathBaconXJF = `fileDialog2 -fm 0 -cap "Export Failure" -ff "Failure (*.fail)" -okc "Save" -cc "Cancel"`;
            break;
    }
    
    if($expFilePathBaconXJF[0] != "")
    {
        tokenize $expFilePathBaconXJF[0] $sepBxjf $fPartsBxjf;
        int $len = size($fPartsBxjf);

        $expFilePathBaconXJF[1] = $fPartsBxjf[0];
        string $apart = ("Index 0: " + $fPartsBxjf[0] + "\n");
        print $apart;
        for($i=1; $i<($len-1); $i++) $expFilePathBaconXJF[1] = $expFilePathBaconXJF[1] + $sepBxjf + $fPartsBxjf[$i];
        
        string $fNamePrts[];
        tokenize $fPartsBxjf[$len-1] "." $fNamePrts;
        $fPartNoFExt = $fNamePrts[0];
        if($expFormatBaconXJF == 1) $vizorHtmlPathBaconXJF = $expFilePathBaconXJF[1] + $sepBxjf + $fPartNoFExt + ".html";

        $expFilePathBaconXJF[2] = $fPartsBxjf[size($fPartsBxjf)-1];
        print $expFilePathBaconXJF;
        
        if($isMayaLtBxjf == false)
        {
            $expFileIdBaconXJF = `fopen $expFilePathBaconXJF[0] "w"`;
        }
        else clear $expStrBaconXJF;

        clear $sgGroups;
        clear $expBxjfMName;
        clear $expBxjfID;

        
        if(`radioButtonGrp -query -select "itemsBxjf"` == 2) $sgGroups = `ls -selection`;
        else
        {
            string $allTransforms[] = `ls -tr`;
            int $tSize = size($allTransforms);
            for($i=0; $i<$tSize; $i++)
            {
                string $rels[] = `listRelatives -ap $allTransforms[$i]`;
                if(size($rels) == 0 && `getAttr ( $allTransforms[$i] + ".visibility" )`) $sgGroups[size($sgGroups)] = $allTransforms[$i];
            }   
        }
        writeFileHeaderBaconXJF();
        writeMetadataBaconXJF();
        writeMaterialsBaconXJF();
        writeTexturesBaconXJF();
        writeSceneGraphBaconXJF();
        writeFileFooterBaconXJF();

        if($expFormatBaconXJF == 1) prtVizorHTMLBxjf();        
        
        if($isMayaLtBxjf == false) fclose $expFileIdBaconXJF;
        else fwriteAllLines $expFilePathBaconXJF[0] $expStrBaconXJF;
    }
    deleteBaconXJFEx;
    string $outputBxjf = "File Exported: " + $expFilePathBaconXJF[0];// + "\n";
    printBxjfStatus($outputBxjf);
    if($expFormatBaconXJF == 1)
    {
        string $prtOutVizorHtmlPath = ("HTML Saved to: " + $vizorHtmlPathBaconXJF);
        printBxjfStatus($prtOutVizorHtmlPath);
        launch -web $vizorHtmlPathBaconXJF;
    }
    
    //Removing temporary attributes that were used to test
    //whether or not a node had already been exported.
    //Then we erase the list of nodes.
    int $els = size($expListBxjf);
    int $iels;
    for($iels = 0; $iels<$els; $iels++)
    {
        deleteAttr ($expListBxjf[$iels] + ".bcnco");
    }
    
    string $newList[];
    $expListBxjf = $newList;
}

global proc showBaconXJFEx()
{
global int $isSelectBxjf;
global int $isMayaLtBxjf;
global int $hasShdrFxBxjf;
global int $cgfxProfBxjf;
global int $shaderConfBxjf;
global string $txtLineLimitBxjf;
global string $sepBxjf;
global string $bcnFormat[];

    $bcnFormat = {"bcnFileFormat","vzrFileFormat","x3dcFileFormat","x3djFileFormat","x3dxFileFormat","x3dhFileFormat","tjsFileFormat","gltfFileFormat"};
    
	string $testLines[];
    string $bPath = `optionVar -q "pathToBaconXJF"`;
	$isMayaLtBxjf = `optionVar -q "isMayaLtBxjf"`;
    $isSelectBxjf = `optionVar -q "isSelectBxjf"`;
    
	int $ovExist_hasShdrFxBxjf = `optionVar -ex "hasShdrFxBxjf"`;
    if($ovExist_hasShdrFxBxjf == 1 ) $hasShdrFxBxjf = `optionVar -q "hasShdrFxBxjf"`;
    else
    {
    	string $dNode[] = `ls -sl`;
    	int $tc = catch( `shadingNode -asShader ShaderfxShader`  );
    	string $aNode[] = `ls -sl`;
    	
    	if(size($aNode) > 0)
    	{
    		if(size($dNode) == 0) $tc = true;
    		else if($aNode[0] == $dNode[0]) $tc = false;
    		else $tc = true;
    		
    		if($tc == true) delete;
    	}
    
    	$hasShdrFxBxjf = $tc;
		optionVar -iv "hasShdrFxBxjf" $hasShdrFxBxjf;
	}
	
    if(!`window -exists "baconXJFEx"`)
    {
        window -title "BaconXJF - 3D Web Format Exporter" -widthHeight 350 360 "baconXJFEx";
        scrollLayout -w 350 -h 360;
            columnLayout "mainColBXJFEX";
                radioButtonGrp -numberOfRadioButtons 2 -label "Items to Export:" -labelArray2 "All" "Selected" -select $isSelectBxjf -columnAlign3 "left" "left" "left" -columnWidth3 80 35 60 -cc "expItemsBaconXJF" "itemsBxjf";
//                radioButtonGrp -numberOfRadioButtons 2 -label "Export Using MayaLT Style:" -labelArray2 "No" "Yes" -select $isMayaLtBxjf -columnAlign3 "left" "left" "left" -columnWidth3 150 35 35 -cc "expStyleBaconXJF" "styleBxjf";
                rowLayout -nc 3 -cw3 30 120 80;
                    text -label " ";
                    text -label "Lines Per Export File: ";
                    textField -text $txtLineLimitBxjf -w 80 -cc "expSetLineValueBaconxXJF" "textFieldLineStringBaconXJF";
                    setParent "mainColBXJFEX";
                text -label "Format:";
                textScrollList -numberOfRows 8
                               -allowMultiSelection false
                               -append "Bacon Wrap"    //BaconXJF Format
                               -append "Vizor VR"      //Vizor VR
                               -append "X3D {classic}" //X3D {classic}
                               -append "X3D { JSON  }" //X3D { JSON  }
                               -append "X3D <  xml  >" //X3D <  xml  >
                               -append "XHTML <3D html>" //XHTML
                               -append "ThreeJS { JSON }" //ThreeJS"
                               -append "glTF { JSON }" //glTF
                               -selectItem "Vizor VR" "bftxTSL";

                if($hasShdrFxBxjf)
                {
                    int $profValBxjf = $cgfxProfBxjf + 1;
                    int $confValBxjf = $shaderConfBxjf + 1;

                    separator -h 5;

                    text -label "ShaderFX Settings:";
                    
                    rowLayout -nc 2 -cw2 30 160;
                        text -label " ";
                        optionMenuGrp -l "CGFX Profile: " -cw2 80 80 -cl2 "left" "left" -cc "expShaderFXProfBaconXJF" "cgfxProfileBaconXJF";
                            menuItem -label "glsl";
                            menuItem -label "gp4";
                            
                        optionMenuGrp -e -select $profValBxjf "cgfxProfileBaconXJF";
                        setParent "mainColBXJFEX";
                    rowLayout -nc 2 -cw2 30 160;
                        text -label " ";
                        optionMenuGrp -l "Shader Config: " -cw2 80 80 -cl2 "left" "left" -cc "expShaderFXConfBaconXJF" "shaderConfBaconXJF";
                            menuItem -label "HLSL_3";
                            menuItem -label "HLSL_5";
                            menuItem -label "GLSL_1_2";
                            menuItem -label "GLSL_4";
                            menuItem -label "CGFX_3";
                            menuItem -label "OSL";
                            
                        optionMenuGrp -e -select $confValBxjf "shaderConfBaconXJF";
                }
                setParent "mainColBXJFEX";
                separator -h 25;
                rowLayout -nc 3 -cw3 120 120 120;
                    text -label " ";//button -label "Debug - Delete Window" -command "deleteBaconXJFEx";
                    text -label " ";
                    button -label "Export File" -command "expSelBaconXJF";
                    
                    setParent "mainColBXJFEX";
                separator -h 10;
                cmdScrollFieldReporter -width 340 -height 60;
    }
    showWindow "baconXJFEx";
    print "\n";
    print "\n";
    print "\n";
}

global proc bacon_xjf_export()
{
	bacon_xjf_json;
	bacon_xjf_xml;
	showBaconXJFEx;
}

//showBaconXJFEx;